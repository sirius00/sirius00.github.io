[{"content":"浏览器运行JS 浏览器分成两部分: 渲染引擎和JS引擎\n渲染引擎: 用来解析HTML和CSS, 俗称内核, 比如chrome浏览器的blink, 老版本的webkit\nJS引擎: 也称为js解释器, 用来读取网页的javascript代码, 对其处理后运行, 比如chrome的v8\n浏览器本身不会执行JS代码, 而是通过内置的JS引擎来执行JS代码, JS引擎执行代码时要逐行解释每一句源码(转化为机器语言), 然后由计算机去执行, 所以javascript语言归为脚本语言, 会逐行解释执行\n解释型语言和编译型语言 编译器实在代码执行之前进行编译, 生成中间代码文件 解释器是在运行时进行及时解释, 并立即执行(当编译器以解释方式运行的时候, 也称为解释器)\nJS的组成 ECMAScript(javascript语法) DOM(页面文档对象模型) 可以对页面上的各种元素进行操作 BOM(浏览器对象模型) 可以操作浏览器窗口, 比如弹出框、控制浏览器跳转、获取分辨率等 JS的三种书写位置 行内式 \u0026lt;input type=\u0026#34;button\u0026#34; value=\u0026#34;点击\u0026#34; onclick=\u0026#34;alert(\u0026#39;点击事件\u0026#39;)\u0026#34;\u0026gt; 内嵌式 外部引用 \u0026lt;script src=\u0026#34;my.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; JS的注释 单行注释 (快捷键: ctrl + /) 多行注释(快捷键: shift + alt + a) // 1. 单行注释 /* 1. 多行注释 */ JS的变量 更新变量 一个变量被重新赋值后, 他原有的值就就被覆盖, 变量值将以最后一次的值为准\n同时声明多个变量 var age=18, name='xiaoqian'\n声明变量的特殊情况\n只声明不赋值, 变量为undefined 不声明不赋值, 直接使用变量会报错 不声明直接赋值使用(可以,会变成全局变量,不推荐) 变量的命名规范\n由字母、数字、下划线、$组成 严格区分大小写 不能以数字开头 不能是关键字、保留字 变量名必须有意义 遵守驼峰命名法, 首字母小写,其他的单词首字母大写 数据类型 javascript是一种弱类型或者说动态语言, 这意味着不用提前声明变量的类型, 在程序运行过程中, 类型会自动被确定. 变量的数据类型会根据 = 右边变量的数据类型来判断的, 运行之后, 变量的类型就会被确定. javascript拥有动态类型, 同时也意味着相同的变量可用于不同的类型.\n简单数据类型 NUmber 数字型进制 数字前面加 0 表示八进制 数字前面加 0x 表示十六进制 数字型范围 最大值: Number.MAX_VALUE 最小值: Number.MIN_VALUE 数值型是那个特殊值 Infinity, 代表无穷大, 大于任何值 -Infinity, 代表无穷小, 小于任何值 NaN, Not a number, 代表一个非数值 isNaN() 方法, 用来判断非数字 String 字符串的嵌套, 采用 外单内双, 外双内单 原则 字符串转义字符 \\ n: 换行符 \\: 斜杠 ': 单引号 \u0026quot;: 双引号 \\t: tab缩进 \\b: 空格 字符串的长度 字符串的拼接 Boolean true = 1, false = 0\nUndefined 如果一个变量声明未赋值, 就是undefined未定义数据类型 undefined 和数字相加 最后结果为NaN\nNull 复杂数据类型 Object 数据类型的转换 转换为字符串类型\ntoString(): var num = 1; alert(num.toString()) String(): var num=1; alert(String(num)) 拼接字符串 转化为数字类型\nparseInt(string)函数: parseInt('78') parseFloat(string)函数: parseFloat('78') Number()强制转换函数: Number('78') js 隐式转换(- * /): 利用算术隐式转换为数值型 转换为布尔类型\nBoolean()函数: Boolean(\u0026rsquo;true') 运算符 算术运算符 浮点数的最高精度是17位小数， 但在运算时其精度远不如整数\n递增和递减运算符 前置递增运算符 ++ 写在变量的前面， 先加一， 然后返回值 后置自增 先表达式返回原值 后面变量再自加1\n比较运算符（关系运算符） == 判等号（会转型） === 全等 要求数值和类型都一致 逻辑运算符 \u0026amp;\u0026amp; 逻辑与 and || 逻辑或 or （有true 则true） ！ 逻辑非 not 短路运算（逻辑中断） 短路运算的原理： 当有多个表达式（值）时， 左边的表达式可以确定结果时， 就不再继续运算右边的表达式的值\n逻辑与 表达式1 \u0026amp;\u0026amp; 表达式2 如果表达式1为真， 则返回表达式2 如果表达式1为假， 则返回表达式1 逻辑或 如果表达式1为真， 则返回表达式1 如果表达式1为假， 则返回表达式2 赋值运算符 +=、-= 表示加、减一个数后再赋值 =、/=、%= 表示乘、除、取模后再赋值\n运算符优先级 小括号： （） 一元运算符： ++ 、\u0026ndash;、！ 算术运算符： 先 */% 后+、- 关系运算符： \u0026gt;、\u0026gt;= 相等运算符 逻辑运算符 赋值运算符 逗号运算符 流程控制 分支 if语句 ifelse语句 if else if 多分支语句 switch语句 switch （表达式）{ case value1: 执行语句1； break； case value2: 执行语句2； break； default： 执行最后的语句； } 注意事项： 1.表达式的值和case里面的值匹配的时候 是 “全等”， 必须数值和数据类型全一致 2. 如果case语句中没有break， 则不会退出switch语句， 是继续执行下一个case 三元表达式 条件表达式 ？ 表达式1 ： 表达式2\n如果表达式结果为真， 则返回表达式1的值 如果表达式结果为假， 则返回表达式2的值 循环 for循环 双重for循环 while循环 do while循环 continue break continue 关键字 用于立即跳出本次循环， 继续下一次循环 break 关键字 退出整个循环\nJS命名规范 标识符命名规范 变量、函数的命名必须有意义 变量的名称一般用名词 函数的名称一般用动词 操作符规范 操作符的左右两侧各保留一个空格 单行注释规范 单行注释前面加一个空格 其他规范 数组 1. 创建数组 使用 new 创建数组 var 数组名 = new Array（） 使用数组字面量创建数组 var 数组名 = [ ] 2. 获取数组中的元素 数组的索引： 数组可以通过索引来访问、设置、修改相应的数组元素， 索引号从0开始\n3. 遍历数组 4. 数组中新增元素 可通过修改length长度以及索引号增加数组元素； 不能直接给数组名赋值， 否则会覆盖掉以前的数据\n函数 函数的参数 形参和实参 形参和实参个数不匹配的问题： 如果实参的个数大于形参， 会取到形参的个数 如果实参的个数小于形参， 多出的形参变量没有接受值， 结果就是undefined\n函数的返回值 return语句 函数只是实现某种功能， 最终的结果需要返回给函数的调用者函数名（） 通过return实现； 如果函数没有return， 则函数返回undefined\narguments的使用 当我们不确定函数有多少个参数传递的时候， 可以使用arguments来获取， arguments实际上是一个内置对象， 所有函数都内置了arguments对象， arguments对象中存储了传递的所有实参。\nfunction fn（）{ console.log(arguments) } fn(1,2,3) arguments展示形式是一个伪数组， 因此可进行遍历， 具有以下特点：\n具有length属性 按索引方式存储数据 不具有数组的push、pop等方法 函数的声明方式 利用关键字自定义函数 function fn（）{ } fn() 函数表达式(匿名函数) var fun = function () { console.log(\u0026#39;121\u0026#39;) } 作用域 作用域 全局作用域： 整个script标签， 或者是一个单独的js文件 局部作用域： 在函数内部就是局部作用域\n变量的作用域 全局变量 局部变量\n作用域链 根据在内部函数可以访问外部函数变量的机制（就近原则）， 用链式查找决定哪些数据能被内部函数访问， 就称作作用域链\n预解析 预解析 js引擎会把js里面所有的 var 还有 function 提升到当前作用域的最前面\n变量预解析（变量提升）和函数预解析（函数提升） 变量提升： 就是把所有的变量声明提升到当前作用域的最前面， 不提升赋值操作 函数提升： 就是把所有的函数声明提升到当前作用域的最前面， 不调用函数\n对象 对象 对象是一组无序的相关属性和方法的集合\n创建对象的三种方式 利用字面量创建对象 var obj = {} var obj = { age: 18, name: \u0026#39;zhangsan\u0026#39;, sayhi: function(){ console.log(\u0026#39;hi\u0026#39;) } } 使用对象 1. 对象名.属性名 console.log(obj.name) 2. 对象名[\u0026#39;属性名\u0026#39;] console.log(obj[\u0026#39;age\u0026#39;]) 3. 使用对象的方法 obj.sayhi() 利用 new 关键字 创建对象 var obj = new Object(); obj.name = \u0026#39;wang\u0026#39; 利用 构造函数 创建对象 为什么需要使用构造函数创建对象？ 就是因为前面两种创建对象的方式一次只能创建一个对象\n构造函数的语法格式： funcion 构造函数名（） { this.属性名 = 值； this.方法名 = function （） {} } new 构造函数名（）； // 1. 构造函数的首字母大写 // 2. 构造函数不需要return， 就可以返回结果 // 3. 调用构造函数， 必须使用 new // 4. function Star（name，age）{ this.name = name; this.age = age } new Star（\u0026#39;刘德华\u0026#39;， 18） new 关键字 new关键字的执行过程;\n在内存中创建一个新的空对象 让 this 指向这个新的对象 执行构造函数里面的代码， 给这个新对象添加属性和方法 返回这个新对象（所以构造函数里面不需要return） 遍历对象属性 for\u0026hellip;in语句 用来对数组活著对象的属性进行循环操作\nfor （var k in obj）{ console.log(k) // 变量 输出 得到的是 属性名 console.log(obj[k]) // 输出的是 属性值 } 内置对象 Math对象 日期对象 日期格式化 获取日期的指定部分：\ngetFullYear（） 格式化日期 时分秒 封装一个函数返回当前的时分秒：\nfunction getTime（）{ var time = new Date() var h = time.getHours() h = h \u0026lt; 10 ? \u0026#39;0\u0026#39; + h : h var m = time.getMinutes() var s = time.getSeconds() return h + \u0026#39;:\u0026#39; + m + \u0026#39;:\u0026#39; + s } 数组对象 创建数组的方式 字面量方式 new Array（） 检测是否为数组： instanceof 运算符 可以用来检测是否为数组 添加删除数组元素 push（）： 末尾添加一个或多个元素， 修改原数组 pop（）： 删除数组最后一个元素， 数组长度减1， 修改原数组 unshift（）： 向数组的开头添加一个元素， 修改原数组 shift（）： 删除数组的第一个元素， 数组长度减1， 修改原数组 数组排序 reverse（）： 颠倒数组中的元素的顺序， 无参数 sort（）： 对数组的元素进行排序 数组索引 indexOf（） lastindexOf（） 数组转字符串 toString（） join（\u0026lsquo;分隔符\u0026rsquo;）\n字符串对象 基本包装类型 就是把简单的数据类型包装成为复杂数据类型， 这样基本数据类型就有了属性和方法\n简单类型和复杂类型 简单数据类型又叫做基本数据类型或值类型， 复杂类型又叫做引用类型 值类型： 简单数据类型/基本数据类型， 在存储变量时存储的是值本身， 因此叫做值类型 引用类型： 复杂数据类型， 在存储时变量中存储的是地址， 因此叫引用数据类型\n","permalink":"https://sirius00.github.io/posts/tech/javascript%E5%9F%BA%E7%A1%80/","summary":"浏览器运行JS 浏览器分成两部分: 渲染引擎和JS引擎 渲染引擎: 用来解析HTML和CSS, 俗称内核, 比如chrome浏览器的blink, 老版本的webkit JS引擎: 也称为js解释器, 用来读取网页的javascript代码, 对其处理后运行, 比如chrome的v8 浏览器本身不会执行JS","title":"Javascript基础"},{"content":"flex布局 容器的属性 flex-direction属性 作用:决定主轴的方向(项目的排列方向)\n.box { flex-direction: row | row-reverse | column | column-reverse; } row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-reverse：主轴为垂直方向，起点在下沿 flex-wrap属性 作用:默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。\n.box{ flex-wrap: nowrap | wrap | wrap-reverse; } nowrap（默认）：不换行 wrap：换行，第一行在上方 wrap-reverse：换行，第一行在下方 flex-flow属性 作用:是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap\n.box { flex-flow: \u0026lt;flex-direction\u0026gt; \u0026lt;flex-wrap\u0026gt;; } justify-content属性 作用:定义了项目在主轴上的对齐方式\n.box { justify-content: flex-start | flex-end | center | space-between | space-around; } flex-start（默认值）：左对齐 flex-end：右对齐 center： 居中 space-between：两端对齐，项目之间的间隔都相等。 space-around：每个项目两侧的间隔相等。所以，项目之间的间隔比项目与边框的间隔大一倍。 align-items属性 作用:定义了项目在交叉轴上如何对齐\n.box { align-items: flex-start | flex-end | center | baseline | stretch; } flex-start：交叉轴的起点对齐。 flex-end：交叉轴的终点对齐。 center：交叉轴的中点对齐。 baseline: 项目的第一行文字的基线对齐。 stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。 align-content属性 作用:定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用\n.box { align-content: flex-start | flex-end | center | space-between | space-around | stretch; } flex-start：与交叉轴的起点对齐。 flex-end：与交叉轴的终点对齐。 center：与交叉轴的中点对齐。 space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。 space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。 stretch（默认值）：轴线占满整个交叉轴。 项目的属性 order ​\t作用:定义项目的排列顺序,数值越小,排列越靠前\n.item { order: \u0026lt;integer\u0026gt;; } flex-grow 作用:定义项目的放大比例,即如果存在剩余空间,也不放大.\n如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。\n.item { flex-grow: \u0026lt;number\u0026gt;; /* default 0 */ } flex-shrink 作用:定义了项目的缩小比例,即如果空间不足,将项目将缩小\n如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。负值对该属性无效。\n.item { flex-shrink: \u0026lt;number\u0026gt;; /* default 1 */ } flex-basis 作用:定义了再分配多余空间之前,项目占据的主轴空间(main size), 浏览器根据这个属性,计算主轴是否还有多余空间\n.item { flex-basis: \u0026lt;length\u0026gt; | auto; /* default auto */ } flex 作用:是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选\n.item { flex: none | [ \u0026lt;\u0026#39;flex-grow\u0026#39;\u0026gt; \u0026lt;\u0026#39;flex-shrink\u0026#39;\u0026gt;? || \u0026lt;\u0026#39;flex-basis\u0026#39;\u0026gt; ] } align-self 作用:允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。\n.item { align-self: auto | flex-start | flex-end | center | baseline | stretch; } CSS实现动画效果 transform属性 transform 属性向元素应用 2D 或 3D 转换。该属性允许我们对元素进行旋转rotate、扭曲skew、缩放scale和移动translate以及矩阵变形matrix\n语法:\ntransform: none|transform-functions; 即： transform: rotate | scale | skew | translate |matrix; 其中none表示不变换, transfrom-function表示一个或多个变换函数, 以空格隔开\n旋转 roate roate(angle): 通过指定的角度参数对原元素指定一个2D旋转\nangle是指旋转角度（单位为deg），如果设置的值为正数表示顺时针旋转，如果设置的值为负数，则表示逆时针旋转。\ntransform: rotate(45deg); 注意：旋转的时候默认以元素中心点为基点进行旋转，可以通过transform-origin属性定义旋转的基点位置\ntransform-origin属性：定义旋转的基点。\n语法：\ntransform-origin: x-axis y-axis z-axis; 默认值：\ntransform-origin: 50% 50% 0; 2D的情况下，默认元素的左上角为0% 0%，例如：绕右下角旋转45度\ntransform-origin: 100% 100%; transform: rotate(45deg); rotate3d(x, y, z, angle)：定义3D旋转\n不常用\nrotateX(angle)：定义沿着X轴的3D旋转\ntransform: rotateX(45deg); roateY(angle): 定义沿着Y轴的3D旋转\ntransform:rotateY(45deg); rotateZ(angle)：定义沿着Z轴的3D旋转\n由以下的例子可以看出，Z轴的方向是垂直于window的方向\ntransform:rotateZ(45deg); 移动 translate translate(x, y): 定义2D移动转化\nx 是第一个过渡值参数，y 是第二个过渡值参数选项。如果未被提供，则ty以 0 作为其值。也就是translate(x,y),它表示对象进行平移，按照设定的x,y参数值,当值为负数时，反方向移动物体，其基点默认为元素中心点，也可以根据transform-origin进行改变基点。\n例如：\ntransform:translate(50px,50px): translate(x): 指定x轴方向上的一个移动\ntransform:translateX(50px): translate(y)：指定Y轴方向上的一个移动\ntransform:translateY(50px): translate3d(x, y, z)：定义3D移动转换\ntranslateZ(z)：指定Z轴方向上的一个移动\n缩放 scale scale(x, y)：定义2D缩放转换。\nX表示水平方向缩放的倍数，Y表示垂直方向的缩放倍数，而Y是一个可选参数，如果没有设置Y值，则表示X，Y两个方向的缩放倍数是一样的。并以X为准。例如：\ntransform: scale(0.7, 0.3); 可以通过transform-origin对元素的基点进行设置，同样基点在元素中心位置；例如：\ntransform-origin: 100% 100%; transform: scale(0.7, 0.3); scaleX(x)：在X轴方向进行缩放转换\ntransform: scaleX(0.7) scaleY(y)：在Y轴方向进行缩放转换\ntransform: scaleY(0.7) scale3d：(x, y, z)：定义3D缩放转换\nscaleZ(z)：在Z轴方向进行缩放转换\n扭曲 skew skew(x-angle, y-angle) ：定义沿着 X 和 Y 轴的 2D 倾斜转换。\nskew是用来对元素进行扭曲变行，第一个参数是水平方向扭曲角度，第二个参数是垂直方向扭曲角度。其中第二个参数是可选参数，如果没有设置第二个参数，那么Y轴为0deg。：\ntransform: skew(10deg,10deg); 同样是以元素中心为基点，我们也可以通过transform-origin来改变元素的基点位置。例如\ntransform-origin: 100% 100%; transform: skew(10deg,10deg); skewX(angle)：定义沿着 X 轴的 2D 倾斜转换\ntransform: skewX(10deg); skewY(angle)：定义沿着 Y轴的 2D 倾斜转换\ntransform: skewY(10deg); 注意：如果要实现3D效果，需要将transform-style属性设置为preserve-3d，即\ntransform-style: preserve-3d; @keyframes CSS3中添加的新属性animation是用来为元素实现动画效果的，但是animation无法单独担当起实现动画的效果。承载动画的另一个属性——@keyframes。使用的时候为了兼容可加上-webkit-、-o-、-ms-、-moz-、-khtml-等前缀以适应不同的浏览器\n创建动画的原理是，将一套 CSS 样式逐渐变化为另一套样式。\n通过 @keyframes 规则，您能够创建动画。\n@keyframes定义一个动画，并定义具体的动画效果，比如是放大还是位移等等。\n@keyframes 它定义的动画并不直接执行，需要借助animation来运转。\n在动画过程中，您能够多次改变这套 CSS 样式。\n以百分比来规定改变发生的时间，或者通过关键词 “from” 和 “to”，等价于 0% 和 100%。\n百分比是指动画完成一遍的时间长度的的百分比 ，0% 是动画的开始时间，50%是动画完成一半的时间，100% 动画的结束时间。百分比后面的花括号写：在动画执行过程中的某时间点要完成的变化。\n为了获得最佳的浏览器支持，您应该始终定义 0% 和 100% 选择器。\n语法:\n@keyframes animationname {keyframes-selector {css-styles;}} 名字为gif的@keyframes ，动画完成需要的总时长为1.4s,刚开始的时候图片旋转为0度，动画完成的时候图片旋转360度\n.load-border { width: 120px; height: 120px; background: url(../images/loading_icon.png) no-repeat center center; -webkit-animation: gif 1.4s infinite linear; animation: gif 1.4s infinite linear; } @keyframes gif { 0% { -webkit-transform: rotate(0deg); transform: rotate(0deg); } 100% { -webkit-transform: rotate(360deg); transform: rotate(360deg); } } 名字为mymove的@keyframes ，动画完成需要的总时长为1s,刚开始的时候图片距顶部距离为0px，0.25s后图片距顶部距离为200px，0.5s后图片距顶部的距离为100px，以此类推\n.img { width: 120px; height: 120px; background: url(../images/icon.png) no-repeat center center; -webkit-animation: gif 1.4s infinite linear; animation: mymove 1s infinite linear; } @keyframes mymove { 0% {top:0px;} 25% {top:200px;} 50% {top:100px;} 75% {top:200px;} 100% {top:0px;} } 在一个动画中改变多个 CSS 样式：\n@keyframes mymove { 0% {top:0px; background:red; width:100px;} 100% {top:200px; background:yellow; width:300px;} } animation(动画)属性 语法 animation: name duration timing-function delay iteration-count direction fill-mode play-state; 值 说明 animation-name 指定要绑定到选择器的关键帧的名称 animation-duration 动画指定需要多少秒或毫秒完成 animation-timing-function 设置动画将如何完成一个周期 animation-delay 设置动画在启动前的延迟间隔。即是指动画延迟执行时间 animation-iteration-count 定义动画的播放次数。无限循环关键字 ==infinite==,即是反复循环播放动画 animation-direction 指定是否应该轮流反向播放动画。 animation-fill-mode 规定当动画不播放时（当动画完成时，或当动画有一个延迟未开始播放时），要应用到元素的样式。 animation-play-state 指定动画是否正在运行或已暂停。 initial 设置属性为其默认值。 inherit 从父元素继承属性。 animation-timing-function 规定动画的速度曲线. 默认是\u0026quot;ease\u0026quot;\n常见的动画速度参数:\nlinear: 线性过渡. ease: 平滑过渡 ease-in: 由慢到快 ease-out: 由快到慢 ease-in-out: 由慢到快再到慢 step-start: 等同于steps(1, start) step-end: 等同于steps(1, end) steps([, [ start | end ] ]?)：接受两个参数的步进函数。第一个参数必须为正整数，指定函数的步数。第二个参数取值可以是start或end，指定每一步的值发生变化的时间点。第二个参数是可选的，默认值为end cubic-bezier(, , , )：特定的贝塞尔曲线类型，4个数值需在[0, 1]区间内 animation-direction 规定动画是否在下一周期逆向的播放. 默认是\u0026quot;normal\u0026quot;\nreverse: 反方向运行 alternate: 动画先正常运行再反方向运行,并持续交替运行 alternate-reverse: 动画先反运行再正方向运行,并持续交替运行 animate-fill-mode 规定对象动画时间之外的状态\nnone: 默认值, 不设置对象动画之外的状态 forwards: 设置对象状态为动画结束时 的状态 backwards: 设置对象状态为动画开始时的状态 both: 设置对象状态为动画结束或开始的状态, 动画开始之前是\u0026quot;form\u0026quot;或\u0026quot;0%\u0026ldquo;关键帧; 动画完成之后是\u0026quot;to\u0026quot;或\u0026quot;100%\u0026ldquo;关键帧状态 ","permalink":"https://sirius00.github.io/posts/tech/html_css/","summary":"flex布局 容器的属性 flex-direction属性 作用:决定主轴的方向(项目的排列方向) .box { flex-direction: row | row-reverse | column | column-reverse; } row（默认值）：主轴为水平方向，起点在左端。 row-reverse：主轴为水平方向，起点在右端。 column：主轴为垂直方向，起点在上沿。 column-revers","title":"HTML_CSS"},{"content":"webpack 安装 首先需要安装Node.js, node.js自带软件包管理工具npm\n查看node版本\nnode -v\n全局安装webpack\nnpm install webpack@3.6.0 -g\n本地安装webpack\n在项目目录下执行\nnpm install webpack@3.6.0 --save-dev\nwebpack的基本使用 项目文件目录: 项目\ndist //打包好的文件\nsrc //项目源码\nwebpack 打包js文件 常规方式 在项目文件夹下\nwebpack ./src/main.js ./dist/bundle.js 简洁的方式 在项目目录下创建webpack.config.js文件\n//从node中引入包内容 //在使用前需要在项目目录执行`npm init`命令 const path = require(\u0026#39;path\u0026#39;) module.exports = { //入口 entry:\u0026#39;./src/main.js\u0026#39;, //出口 output: { //动态获取路径 //用于拼接两个变量 path: path.resolve(__dirname, \u0026#39;dist\u0026#39;), filename: \u0026#39;bundle.js\u0026#39; } } //便捷打包方式:直接在命令行输入\u0026#39;webpack\u0026#39;,就可以执行打包命令 更高效的方式 在项目目录下执行命令:\nnpm init\n修改package.json文件\n\u0026#34;scripts\u0026#34;: { \u0026#34;test\u0026#34;: \u0026#34;echo \\\u0026#34;Error: no test specified\\\u0026#34; \u0026amp;\u0026amp; exit 1\u0026#34;, //使用 npm run build执行 //会优先使用本地版本webpack \u0026#34;build\u0026#34;: \u0026#34;webpack\u0026#34; }, loader 安装loader 配置loader 修改在项目目录下的webpack.config.js文件\n在module.exports中添加以下部分\n//css-loader module: { rules: [ { test: /\\.css$/, //css-loader 只负责将css文件进行加载 //style-loader负责将样式添加到DOM中 //使用多个loader时,是从右向左读取的 use: [ \u0026#39;style-loader\u0026#39;, \u0026#39;css-loader\u0026#39;], }, ], }, 安装css-loader 以下命令默认安装最新版本的css-loader\nnpm install --save-dev css-lader\n在mac中,由于安装的webpack3.6.0版本,直接执行以上命令,容易出现错误(版本不匹配):\n![image-20220311172138730](/Users/cobb/Library/Application Support/typora-user-images/image-20220311172138730.png)\n指定版本安装方法:\nnpm install --save-dev css-loader@0.28.11\n安装style-loader 安装最新版本的:\nnpm install style-loader --save-dev\n安装webpack3.6.0适配版本style-loader\nnpm install --save-dev style-loader@0.15.0\nless文件处理 安装对应webpack3.6.0版本的less和less-loader\nnpm install --save-dev less-loader@5.0.0 less@3.13.1\n图片文件处理 安装url-loader\nnpm install --save-devurl-loader@1.1.2\n在webpack.config.js文件中添加如下部分:\n{ test: /\\.(png|jpg|gif|jpeg)$/i, use: [ { loader: \u0026#39;url-loader\u0026#39;, options: { //当加载的图片,小于limit时,会将图片编译成base64字符串的形式 //当加载的图片大于limit时,需要使用file-loader模块进行加载 limit: 50000, //在dist文件夹下生成img文件夹以及和原图片同名的文件 name: \u0026#39;img/[name].[hash:8].[ext]\u0026#39; }, } ] } ES6转ES5语法 使用babel-loader\n引入vue.js 通过npm安装vue 因为在后续的实际项目中也会使用vue,所以并不是开发时依赖,不用加**-dev** npm install vue --save 在js文件中引入vue import Vue from vue 出现runtime-only错误:\n原因:\nruntime-only,代码中不可以有任何的template runtime-compiler,代码中可以有template,因为有compiler可以编译template 解决办法:在webpack.config.js文件中添加如下:\nresolve:{ alias:{ \u0026#39;vue$\u0026#39;: \u0026#39;vue/dist/vue.esm.js\u0026#39; } vue应用中\u0026rsquo;el\u0026rsquo;和\u0026rsquo;template\u0026rsquo;区别 template会将el中的内容进行替换\n正确使用vue的方式 安装vue-loader和vue-template-compiler\n配置webpack.config.js\n{ test: /\\.vue$/, use: [\u0026#39;vue-loader\u0026#39;] } 在src文件夹下创建vue文件夹\n![image-20220312151241214](/Users/cobb/Library/Application Support/typora-user-images/image-20220312151241214.png)\nPlugin 添加版权的plugin 使用bannerplugin插件,webpack自带插件\n修改webpack.config.js文件\n打包html的plugin HtmlWebpackPlugin插件可以做的事情:\n自动打包生成一个index.html文件(可以指定模板来生成) 将打包的js文件,自动通过script标签插入到bady中 安装之后配置webpack.config.js文件如下:\nnew HtmlWebpackPlugin({ //根据以下模板生成 template: `index.html` }) js压缩的Plugin 使用第三方的插件Uglifyjs-webpack-plugin\n需要指定版本号1.1.1,保持和CIL2一致\nnpm install --save-dev uglifyjs-webpack-plugin@1.1.1\n搭建本地服务器 这个本地服务器基于node.js,内部使用express框架,可以实现浏览器自动刷新显示修改后的结果\n安装: npm install --save-dev webpack-dev-server@2.9.3\n设置:\ndevserver也是作为webpack中的一个选项,可以设置如下属性:\ncontentBase:为哪一个文件夹提供本地服务 port:端口号 inline:页面实时刷新 historyApiFallback:在SPA页面中,依赖html5的history模式 启动方式:\n在package.json文件中添加: \u0026quot;dev\u0026quot;: \u0026quot;webpack-dev-derver\u0026quot; 在后面添加 --open ,能够在启动服务器的同时自动打开浏览器 在终端中输入: npm rundev webpack配置的分离 首先对webpack.config.js文件进行抽离,分成三部分: base.config.js dev.config.js prod.config.js 安装-webpack-merge插件,实现config文件的两两合并 在package.json文件中修改\u0026quot;build\u0026quot;和\u0026quot;dev\u0026quot;的运行路径 BUG记录 安装npm出现错误:\nnpm ERR! code EACCES npm ERR! syscall rename npm ERR! path /usr/local/lib/node_modules/npm npm ERR! dest /usr/local/lib/node_modules/.npm-i9nnxROI npm ERR! errno -13 npm ERR! Error: EACCES: permission denied, rename \u0026#39;/usr/local/lib/node_modules/npm\u0026#39; -\u0026gt; \u0026#39;/usr/local/lib/node_modules/.npm-i9nnxROI\u0026#39; npm ERR! [Error: EACCES: permission denied, rename \u0026#39;/usr/local/lib/node_modules/npm\u0026#39; -\u0026gt; \u0026#39;/usr/local/lib/node_modules/.npm-i9nnxROI\u0026#39;] { npm ERR! errno: -13, npm ERR! code: \u0026#39;EACCES\u0026#39;, npm ERR! syscall: \u0026#39;rename\u0026#39;, npm ERR! path: \u0026#39;/usr/local/lib/node_modules/npm\u0026#39;, npm ERR! dest: \u0026#39;/usr/local/lib/node_modules/.npm-i9nnxROI\u0026#39; npm ERR! } npm ERR! npm ERR! The operation was rejected by your operating system. npm ERR! It is likely you do not have the permissions to access this file as the current user npm ERR! npm ERR! If you believe this might be a permissions issue, please double-check the npm ERR! permissions of the file and its containing directories, or try running npm ERR! the command again as root/Administrator. npm ERR! A complete log of this run can be found in: npm ERR! /Users/cobb/.npm/_logs/2022-03-10T13_55_54_267Z-debug.log 解决办法:\n需要在命令前加上 ==sudo==\n","permalink":"https://sirius00.github.io/posts/tech/webpack%E7%9A%84%E4%BD%BF%E7%94%A8/","summary":"webpack 安装 首先需要安装Node.js, node.js自带软件包管理工具npm 查看node版本 node -v 全局安装webpack npm install webpack@3.6.0 -g 本地安装webpack 在项目目录下执行 npm install webpack@3.6.0 --save-dev webpack的基本使用 项目文件目录: 项目 dist //打包好的文件 src //项目源码 webpack 打包js文件 常规方式 在项目文件夹下 webpack","title":"Webpack的使用"},{"content":"Vue2学习笔记 认识vue 渐进式框架,什么是渐进式? 渐进式意味着你可以将vue作为你应用的一部分嵌入其中\nvue特点 解耦视图和数据\n可复用的组件\n前端路由技术\n状态管理\n虚拟DOM\n安装 响应式开发 生命周期 webstorm 模板功能 基础知识 插值操作 mustache语法 \u0026lt;span\u0026gt;Message: {{ msg }}\u0026lt;/span\u0026gt; v-once语法 \u0026lt;span v-once\u0026gt;这个将不会改变: {{ msg }}\u0026lt;/span\u0026gt; v-html \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; {{message}} \u0026lt;h2 v-html=\u0026#34;url\u0026#34;\u0026gt;\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;/js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; let app = new Vuae({ el:\u0026#39;#app\u0026#39;, data:{ message:\u0026#34;hello\u0026#34;, url:\u0026#39;\u0026lt;a href=\u0026#34;www.baidu.com\u0026#34;\u0026gt;百度一下\u0026lt;/a\u0026gt;\u0026#39; } }) \u0026lt;/script\u0026gt; v-cloak 作用:在vue解析之前,div中有一个属性v-cloak;\n在vue解析之后,div中没有属性v-cloak\n\u0026lt;style\u0026gt; [v-cloak]{ display: none; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34; v-cloak\u0026gt; \u0026lt;h2\u0026gt;{{message}}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; setTimeout(function(){ let app = new Vue({ el:\u0026#39;#app\u0026#39;, data:{ message:\u0026#34;hello\u0026#34; } }) },1000) \u0026lt;/script\u0026gt; v-pre \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;{{message}}\u0026lt;/h2\u0026gt; \u0026lt;h2 v-pre\u0026gt; {{message}}\u0026lt;/h2\u0026gt; #不做解析,原封不动 \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; let app = new Vue({ el:\u0026#39;#app\u0026#39;, data:{ message:\u0026#34;hello\u0026#34; } }) \u0026lt;/script\u0026gt; v-text \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; {{message}} \u0026lt;h2 v-text=\u0026#34;message\u0026#34;\u0026gt;,hello\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; let app = new Vue({ el:\u0026#39;#app\u0026#39;, data:{ message:\u0026#34;hello\u0026#34; } }) \u0026lt;/script\u0026gt; 绑定属性 v-bind的基本使用 \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;{{message}}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;\u0026lt;/h2\u0026gt; \u0026lt;img v-bind:src=\u0026#34;imgurl\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt; \u0026lt;!-- v-bind语法糖,即简写方式--\u0026gt; \u0026lt;!-- \u0026lt;img :src=\u0026#34;imgurl\u0026#34; alt=\u0026#34;\u0026#34;\u0026gt;--\u0026gt; \u0026lt;/div\u0026gt; v-bind动态绑定的class \u0026lt;style\u0026gt; .active{ color: red; } \u0026lt;/style\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h2 :class=\u0026#34;active\u0026#34;\u0026gt;{{message}}\u0026lt;/h2\u0026gt; \u0026lt;!-- 对象语法--\u0026gt; \u0026lt;!-- \u0026lt;h2 v-bind:class=\u0026#34;{key1:vlue1,key2:value2}\u0026#34;\u0026gt;\u0026lt;/h2\u0026gt;--\u0026gt; \u0026lt;!-- \u0026lt;h2 v-bind:class=\u0026#34;{类名1: true , 类名2: boolean}\u0026#34;\u0026gt;\u0026lt;/h2\u0026gt;--\u0026gt; \u0026lt;!-- 可以同时加载原始的class,两个之间会自动合并--\u0026gt; \u0026lt;h2 v-bind:class=\u0026#34;{active: isActive , line: isLine}\u0026#34; class=\u0026#34;title\u0026#34;\u0026gt;{{message}}\u0026lt;/h2\u0026gt; \u0026lt;h2 v-bind:class=\u0026#34;getClasses()\u0026#34; class=\u0026#34;title\u0026#34;\u0026gt;{{message}}\u0026lt;/h2\u0026gt; \u0026lt;button v-on:click=\u0026#34;btnClick\u0026#34;\u0026gt;按钮\u0026lt;/button\u0026gt; \u0026lt;!-- 数组语法--\u0026gt; \u0026lt;h2 :class=\u0026#34;[\u0026#39;active\u0026#39;,\u0026#39;line\u0026#39;]\u0026#34; class=\u0026#34;title\u0026#34;\u0026gt;\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; let app = new Vue({ el:\u0026#39;#app\u0026#39;, data:{ message:\u0026#34;hello\u0026#34;, active:\u0026#39;active\u0026#39;, isActive:true, isLine:true }, methods:{ btnClick:function (){ this.isActive = !this.isActive }, getClasses:function(){ return {active: this.isActive , line: this.isLine} } } }) \u0026lt;/script\u0026gt; v-bind动态绑定style 绑定方式一:对象语法\n:style=\u0026#34;{color:currentColor, fontSize:fontSize + \u0026#39;px\u0026#39;}\u0026#34; 计算属性 基本使用 computed:{ fullName:function (){ return this.firstname + \u0026#39; \u0026#39; + this.lastname } 计算属性的getter和setter \u0026lt;script\u0026gt; let app = new Vue({ el:\u0026#39;#app\u0026#39;, data:{ firstname:\u0026#39;小明\u0026#39;, lastname:\u0026#39;王\u0026#39; }, //计算属性一般是没有set方法,只读属性 computed:{ //简便写法 // fullName:function (){ // return this.firstname + \u0026#39; \u0026#39; + this.lastname // } //原始属性 fullName:{ set:function (newvalue){ const name = newvalue.split(\u0026#39; \u0026#39;); this.firstname = name[0]; this.lastname = name[1]; }, get:function (){ return this.firstname + \u0026#39; \u0026#39; + this.lastname } } } }) \u0026lt;/script\u0026gt; 计算属性和methods \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!-- 方法一 直接拼装 : 语法过于繁琐--\u0026gt; \u0026lt;h2\u0026gt;{{firstname}} {{lastname}}\u0026lt;/h2\u0026gt; \u0026lt;!-- 方法二 通过定义methods,需要多次使用时,需要多次调用--\u0026gt; \u0026lt;h2\u0026gt;{{getfullName()}}\u0026lt;/h2\u0026gt; \u0026lt;!-- 方法三 通过computed,多次调用时,可以实现缓存,只调用一次,更高效--\u0026gt; \u0026lt;h2\u0026gt;{{fullName}}\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; let app = new Vue({ el:\u0026#39;#app\u0026#39;, data:{ firstname:\u0026#39;小明\u0026#39;, lastname:\u0026#39;王\u0026#39; }, computed:{ fullName:function (){ return this.firstname + \u0026#39; \u0026#39; + this.lastname } }, methods:{ getfullName(){ return this.firstname + \u0026#39; \u0026#39; + this.lastname } } }) \u0026lt;/script\u0026gt; 复杂操作 \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;总价格:{{totalPrice}}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; let app = new Vue({ el:\u0026#39;#app\u0026#39;, data:{ books:[ {id: 110, name: \u0026#39;python编程\u0026#39;, price: 120}, {id: 112, name: \u0026#39;c编程\u0026#39;, price: 120}, ] }, computed:{ totalPrice:function (){ let total = 0 for (let i in this.books){ total += this.books[i].price } return total } } }) \u0026lt;/script\u0026gt; 事件监听 v-on的基本使用 \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;{{counter}}\u0026lt;/h2\u0026gt; \u0026lt;button v-on:click=\u0026#34;increment\u0026#34;\u0026gt;+\u0026lt;/button\u0026gt; \u0026lt;button v-on:click=\u0026#34;decrement\u0026#34;\u0026gt;-\u0026lt;/button\u0026gt; \u0026lt;!-- 语法糖写法--\u0026gt; \u0026lt;!-- \u0026lt;button @click=\u0026#34;increment\u0026#34;\u0026gt;\u0026lt;/button\u0026gt;--\u0026gt; \u0026lt;h2\u0026gt;\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; let app = new Vue({ el:\u0026#39;#app\u0026#39;, data:{ counter:0 }, methods:{ increment(){ this.counter++ }, decrement(){ this.counter-- } } }) \u0026lt;/script\u0026gt; v-on的参数传递 \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!-- 调用方法没有参数--\u0026gt; \u0026lt;button @click=\u0026#34;btnclick1\u0026#34;\u0026gt;按钮1\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;btnclick1()\u0026#34;\u0026gt;按钮1\u0026lt;/button\u0026gt; \u0026lt;!-- 在事件定义时,写函数时省略了小括号,但是方法本身需要一个参数--\u0026gt; \u0026lt;!-- 如果函数需要参数,但是没有传入,那么函数的形参为undefined--\u0026gt; \u0026lt;button @click=\u0026#34;btnclick2(123)\u0026#34;\u0026gt;按钮2\u0026lt;/button\u0026gt; \u0026lt;button @click=\u0026#34;btnclick2()\u0026#34;\u0026gt;按钮2\u0026lt;/button\u0026gt; \u0026lt;!-- vue会默认将浏览器生产的event事件对象做作为参数传入到方法--\u0026gt; \u0026lt;button @click=\u0026#34;btnclick2\u0026#34;\u0026gt;按钮2\u0026lt;/button\u0026gt; \u0026lt;!--方法定义时,需要event对象,又需要其他参数--\u0026gt; \u0026lt;!-- 手动获取浏览器参数的event对象: $event --\u0026gt; \u0026lt;button @click=\u0026#34;btnclick3(123, $event)\u0026#34;\u0026gt;按钮3\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; let app = new Vue({ el:\u0026#39;#app\u0026#39;, data:{ message:\u0026#34;hello\u0026#34; }, methods:{ btnclick1(){ console.log(\u0026#34;btnclick1\u0026#34;) }, btnclick2(abc){ console.log(\u0026#34;------\u0026#34;,abc) }, btnclick3(abc, event){ console.log(\u0026#34;+++\u0026#34;, abc, event) } } }) \u0026lt;/script\u0026gt; v-on的修饰符 \u0026lt;div id=\u0026#34;app\u0026#34; @click=\u0026#34;divclick\u0026#34;\u0026gt; \u0026lt;!-- .stop修饰符: 阻止事件冒泡--\u0026gt; \u0026lt;button @click.stop=\u0026#34;btnclick\u0026#34;\u0026gt;按钮\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;br\u0026gt; \u0026lt;!-- .prevent修饰符: 阻止默认事件--\u0026gt; \u0026lt;form action=\u0026#34;baidu\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;提交\u0026#34; @click.prevent=\u0026#34;submitclick\u0026#34;\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;!-- 监听键盘某个键--\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; @keyup.enter=\u0026#34;keyup\u0026#34;\u0026gt; \u0026lt;!--v-once--\u0026gt; 条件渲染 v-if v-if和v-else \u0026lt;div id=\u0026#34;app\u0026#34; \u0026gt; \u0026lt;h2 v-if=\u0026#34;isShow\u0026#34;\u0026gt; \u0026lt;div\u0026gt;{{message}}\u0026lt;/div\u0026gt; \u0026lt;/h2\u0026gt; \u0026lt;h1 v-else\u0026gt;isShow为false时,显示我\u0026lt;/h1\u0026gt; \u0026lt;h2\u0026gt;\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; v-else-if \u0026lt;div v-if=\u0026#34;type === \u0026#39;A\u0026#39;\u0026#34;\u0026gt; A \u0026lt;/div\u0026gt; \u0026lt;div v-else-if=\u0026#34;type === \u0026#39;B\u0026#39;\u0026#34;\u0026gt; B \u0026lt;/div\u0026gt; \u0026lt;div v-else-if=\u0026#34;type === \u0026#39;C\u0026#39;\u0026#34;\u0026gt; C \u0026lt;/div\u0026gt; \u0026lt;div v-else\u0026gt; Not A/B/C \u0026lt;/div\u0026gt; key的使用和案例 \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;span v-if=\u0026#34;showCount\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;username\u0026#34;\u0026gt;账号:\u0026lt;/label\u0026gt; //for的作用,关联标签 \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;请输入账号\u0026#34; id=\u0026#34;username\u0026#34; key=\u0026#34;user\u0026#34;\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;span v-else\u0026gt; \u0026lt;label \u0026gt;邮箱:\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; placeholder=\u0026#34;请输入邮箱\u0026#34; key=\u0026#34;email\u0026#34;\u0026gt; \u0026lt;/span\u0026gt; \u0026lt;button type=\u0026#34;submit\u0026#34; @click=\u0026#34;change\u0026#34; \u0026gt;切换类型\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!--key 的作用,解决输入文本框中文字时,vue渲染时出现共用相同的输入框--\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; let app = new Vue({ el:\u0026#39;#app\u0026#39;, data:{ message:\u0026#34;hello\u0026#34;, showCount:true }, methods:{ change(){ return this.showCount = !this.showCount } } }) \u0026lt;/script\u0026gt; v-show \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;h2 v-if=\u0026#34;isShow\u0026#34;\u0026gt;{{message}}\u0026lt;/h2\u0026gt; \u0026lt;!-- v-show的值为false时,v-show只是给元素添加一个行内样式display:none--\u0026gt; \u0026lt;h2 v-show=\u0026#34;isShow\u0026#34;\u0026gt;{{message}}\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; 列表渲染(循环遍历) v-for遍历数组元素 \u0026lt;ul id=\u0026#34;example-1\u0026#34;\u0026gt; \u0026lt;li v-for=\u0026#34;item in items\u0026#34; :key=\u0026#34;item.message\u0026#34;\u0026gt; {{ item.message }} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; //同时支持访问第二参数,即当前项的索引 \u0026lt;ul id=\u0026#34;example-2\u0026#34;\u0026gt; \u0026lt;li v-for=\u0026#34;(item, index) in items\u0026#34;\u0026gt; {{ parentMessage }} - {{ index }} - {{ item.message }} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; v-for 访问对象 \u0026lt;ul id=\u0026#34;v-for-object\u0026#34; class=\u0026#34;demo\u0026#34;\u0026gt; \u0026lt;li v-for=\u0026#34;value in object\u0026#34;\u0026gt; {{ value }} \u0026lt;/li\u0026gt; \u0026lt;/ul\u0026gt; //同时支持第二,第三参数 \u0026lt;div v-for=\u0026#34;(value, name, index) in object\u0026#34;\u0026gt; {{ index }}. {{ name }}: {{ value }} \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; new Vue({ el: \u0026#39;#v-for-object\u0026#39;, data: { object: { title: \u0026#39;How to do lists in Vue\u0026#39;, author: \u0026#39;Jane Doe\u0026#39;, publishedAt: \u0026#39;2016-04-10\u0026#39; } } }) \u0026lt;/script\u0026gt; 在使用v-for时尽量配合key使用 作用:为了更高效的更新虚拟DOM\n数组更新 push() pop() shift() unshift() splice() sort() reverse() 表单数据绑定v-model v-model的基本使用 \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;text\u0026#34; v-model=\u0026#34;message\u0026#34;\u0026gt; \u0026lt;h2\u0026gt;{{message}}\u0026lt;/h2\u0026gt; \u0026lt;h2\u0026gt;\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; let app = new Vue({ el:\u0026#39;#app\u0026#39;, data:{ message:\u0026#34;hello\u0026#34; } }) \u0026lt;/script\u0026gt; v-model结合checkbox \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; id=\u0026#34;agree\u0026#34; v-model=\u0026#34;isAgree\u0026#34;\u0026gt;同意协议 \u0026lt;label for=\u0026#34;agree\u0026#34;\u0026gt;\u0026lt;/label\u0026gt; \u0026lt;h2\u0026gt;同意协议:{{isAgree}}\u0026lt;/h2\u0026gt; \u0026lt;button :disabled=\u0026#34;!isAgree\u0026#34;\u0026gt;下一步\u0026lt;/button\u0026gt; \u0026lt;br\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; id=\u0026#34;jack\u0026#34; value=\u0026#34;jack\u0026#34; v-model=\u0026#34;checked\u0026#34;\u0026gt;jack \u0026lt;label for=\u0026#34;jack\u0026#34;\u0026gt;\u0026lt;/label\u0026gt; \u0026lt;input type=\u0026#34;checkbox\u0026#34; id=\u0026#34;joy\u0026#34; value=\u0026#34;joy\u0026#34; v-model=\u0026#34;checked\u0026#34;\u0026gt;joy \u0026lt;label for=\u0026#34;joy\u0026#34;\u0026gt;\u0026lt;/label\u0026gt; \u0026lt;h3\u0026gt;chengbox:{{checked}}\u0026lt;/h3\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; let app = new Vue({ el:\u0026#39;#app\u0026#39;, data:{ message:\u0026#34;hello\u0026#34;, isAgree:false, checked:[] } }) \u0026lt;/script\u0026gt; v-model结合radio \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;label for=\u0026#34;male\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; id=\u0026#34;male\u0026#34; v-model=\u0026#34;sex\u0026#34; value=\u0026#34;男\u0026#34;\u0026gt; 男 \u0026lt;/label\u0026gt; \u0026lt;label for=\u0026#34;female\u0026#34;\u0026gt; \u0026lt;input type=\u0026#34;radio\u0026#34; id=\u0026#34;female\u0026#34; v-model=\u0026#34;sex\u0026#34; value=\u0026#34;女\u0026#34;\u0026gt;女 \u0026lt;/label\u0026gt; \u0026lt;h2\u0026gt;选择的性别:{{sex}}\u0026lt;/h2\u0026gt; \u0026lt;!-- \u0026lt;label for=\u0026#34;male\u0026#34;\u0026gt;--\u0026gt; \u0026lt;!-- \u0026lt;input type=\u0026#34;radio\u0026#34; id=\u0026#34;male\u0026#34; name=\u0026#34;sex\u0026#34; v-model=\u0026#34;sex\u0026#34; value=\u0026#34;男\u0026#34;\u0026gt; 男--\u0026gt; \u0026lt;!-- \u0026lt;/label\u0026gt;--\u0026gt; \u0026lt;!-- \u0026lt;label for=\u0026#34;female\u0026#34;\u0026gt;--\u0026gt; \u0026lt;!-- \u0026lt;input type=\u0026#34;radio\u0026#34; id=\u0026#34;female\u0026#34; name=\u0026#34;sex\u0026#34; v-model=\u0026#34;sex\u0026#34; value=\u0026#34;女\u0026#34;\u0026gt;女--\u0026gt; \u0026lt;!-- \u0026lt;/label\u0026gt;--\u0026gt; \u0026lt;!-- \u0026lt;h2\u0026gt;选择的性别:{{sex}}\u0026lt;/h2\u0026gt;--\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; let app = new Vue({ el:\u0026#39;#app\u0026#39;, data:{ message:\u0026#34;hello\u0026#34;, sex:\u0026#39;男\u0026#39; } }) \u0026lt;/script\u0026gt; 组件化开发 注册组件的步骤 创建组件构造器 注册组件 使用组件 调用Vue.extend()方法 创建组件构造器\n调用Vue.conponent()方法 注册组件\n在vue实例的作用域中使用组件\n组件化的基本使用 \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;!-- //3、使用组件--\u0026gt; \u0026lt;my-cpn\u0026gt;\u0026lt;/my-cpn\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script\u0026gt; //1、创建组件构造器 //tab键上方的点可以用来定义字符串,可以换行定义 const cpnC = Vue.extend({ template:` \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;我是标题\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; ` }) //2、注册组件 Vue.component(\u0026#39;my-cpn\u0026#39;,cpnC) let app = new Vue({ el:\u0026#39;#app\u0026#39;, data:{ message:\u0026#34;hello\u0026#34; } }) \u0026lt;/script\u0026gt; 全局组件和局部组件 //注册组件(全局组件) Vue.component(\u0026#39;cpn\u0026#39;,cpnC) let app = new Vue({ el:\u0026#39;#app\u0026#39;, data:{ message:\u0026#34;hello\u0026#34; }, //注册局部组件 components:{ //cpn使用组件的标签名 cpn:cpnC } }) let app2 = new Vue({ el:\u0026#39;#app2\u0026#39;, data:{ message:\u0026#34;hello\u0026#34; } }) 父组件和子组件 //创建第一个组件构造器 const cpnC1 = Vue.extend({ template:` \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;我是标题1\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; `, }) //创建第二个组件构造器 const cpnC2 = Vue.extend({ template:` \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;我是标题2\u0026lt;/h2\u0026gt; \u0026lt;cpn1\u0026gt;\u0026lt;/cpn1\u0026gt; \u0026lt;/div\u0026gt; `, components:{ cpn1: cpnC1 } }) let app = new Vue({ el:\u0026#39;#app\u0026#39;, data:{ message:\u0026#34;hello\u0026#34; }, components:{ // cpn1: cpnC1, cpn2: cpnC2 } }) 组建的语法糖写法 \u0026lt;script\u0026gt; //语法糖写法,注册全局组件 Vue.component(\u0026#39;cpn1\u0026#39;,{ template:` \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;我是标题1\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt;` }) let app = new Vue({ el:\u0026#39;#app\u0026#39;, data:{ message:\u0026#34;hello\u0026#34; }, //注册局部组件 components:{ \u0026#39;cpn2\u0026#39;:{ template:` \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;我是标题2\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; ` } } }) \u0026lt;/script\u0026gt; 组件模板分离写法 \u0026lt;!--方法一 --\u0026gt; \u0026lt;!--\u0026lt;script type=\u0026#34;text/x-template\u0026#34; id=\u0026#34;cpn\u0026#34;\u0026gt;--\u0026gt; \u0026lt;!-- \u0026lt;div\u0026gt;--\u0026gt; \u0026lt;!-- \u0026lt;h2\u0026gt;我是标题1\u0026lt;/h2\u0026gt;--\u0026gt; \u0026lt;!-- \u0026lt;/div\u0026gt;--\u0026gt; \u0026lt;!--\u0026lt;/script\u0026gt;--\u0026gt; 方法二,tempalte标签 \u0026lt;template id=\u0026#34;cpn\u0026#34;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;我是标题\u0026lt;/h2\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; Vue.component(\u0026#39;cpn\u0026#39;,{ template:\u0026#39;#cpn\u0026#39; }) let app = new Vue({ el:\u0026#39;#app\u0026#39;, data:{ message:\u0026#34;hello\u0026#34; } }) \u0026lt;/script\u0026gt; 组件的数据存放 Vue.component(\u0026#39;cpn\u0026#39;,{ template:\u0026#39;#cpn\u0026#39;, //每个组件都是独立的实例对象,如果data不是一个函数,在组件复用的时候会出现数据不能独立的情况 data(){ return { counter:0 } }, methods:{ increment(){ this.counter++ }, decrement(){ this.counter-- } } }) 组件通信-父传子 \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;cpn v-bind:cmovies=\u0026#34;movies\u0026#34; :cmessage=\u0026#34;message\u0026#34;\u0026gt; \u0026lt;/cpn\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;template id=\u0026#34;cpn\u0026#34;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h2\u0026gt;{{cmovies}}\u0026lt;/h2\u0026gt; \u0026lt;div\u0026gt;{{cmessage}}\u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script src=\u0026#34;../js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; const cpn = { template:`#cpn`, // props:[\u0026#39;cmovies\u0026#39;,\u0026#39;cmessage\u0026#39;] props:{ // 1、类型限制 // cmovies:Array, // cmessage:String, //提供一些默认值,以及必传值 cmessage:{ type:String, default:\u0026#39;aaaaa\u0026#39;, //表示该值为必须传入 required:true }, //类型是对象或者数组时,默认值必须是一个函数 cmovies:{ type:Array, dafault(){ return [] } } } } let app = new Vue({ el:\u0026#39;#app\u0026#39;, data:{ message:\u0026#34;hello\u0026#34;, movies:[\u0026#39;海贼王\u0026#39;,\u0026#39;海尔兄弟\u0026#39;] }, components:{ cpn } }) \u0026lt;/script\u0026gt; 组件通信-子传父 \u0026lt;!--父组件模板--\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;cpn @itemclick=\u0026#34;cpnClick\u0026#34;\u0026gt;\u0026lt;/cpn\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;!--子组件模板--\u0026gt; \u0026lt;template id=\u0026#34;cpn\u0026#34;\u0026gt; \u0026lt;div\u0026gt; \u0026lt;button v-for=\u0026#34;item in categories\u0026#34; @click=\u0026#34;btnClick(item)\u0026#34;\u0026gt; {{item.name}} \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; //子组件 const cpn = { template:`#cpn`, data(){ return { categories:[ {id: \u0026#39;aaa\u0026#39;, name: \u0026#39;热门推荐\u0026#39;}, {id: \u0026#39;bbb\u0026#39;, name: \u0026#39;手机数码\u0026#39;}, {id: \u0026#39;ccc\u0026#39;, name: \u0026#39;数码家电\u0026#39;} ] } }, methods:{ btnClick(item){ //发射事件(\u0026#39;自定事件的名字\u0026#39;, 参数) this.$emit(\u0026#39;itemclick\u0026#39;, item) } } } //父组件 let app = new Vue({ el:\u0026#39;#app\u0026#39;, data:{ message:\u0026#34;hello\u0026#34; }, components:{ cpn }, methods:{ cpnClick(item){ console.log(\u0026#39;cpnclick\u0026#39;, item) } } }) \u0026lt;/script\u0026gt; Vue CLI 使用前提 什么是npm: ​\t全称:Node Package Manager\n​\t包管理工具\ncnpm的安装 ​\t原因:国内访问npm官方镜像比较慢\n​\t淘宝npm镜像安装:\n​\tnpm install -g cnpm -- register=http://register.npm.taobao.org\n​\t使用方法:\n​\tcnpm install [包name]\nvue cli的使用 安装vue脚手架 npm install -g @vue/cli\n同时使用cli3和cli2方法: npm install -g @vue/cli-init\nvue cli2 初始化项目 vue init webpack my-project\nruntime-only 和 runtime-compiler的区别: runtime-compiler: template -\u0026gt;ast(抽象语法树)-\u0026gt;render-\u0026gt;vdom-ui runtime-only: render-vdom UI 下面的性能更好,代码量更少 vue cli3 初始化项目 vue create my-project\nvue-rounter 改变URL不刷新界面的方式 location.hash = \u0026lsquo;xxx\u0026rsquo; HTML的history模式: pushState: history.pushState({}, \u0026lsquo;\u0026rsquo;, \u0026lsquo;home\u0026rsquo;) 压入栈 history.back: replaceState: history.replaceState({}, \u0026lsquo;\u0026rsquo;, \u0026lsquo;home\u0026rsquo;) 替换 go : history.go(number) 使用vue-rounter 导入路由对象,并且调用vue.use(vuerounter) 创建路由实例,并且传入路由映射配置 在vue实例中挂载创建的路由实例 vue-rounter的基本使用 搭建步骤 在src文件夹目录下创建rounter目录,然后创建index.js文件,配置如下\n配置路由相关的信息 import VueRouter from \u0026#39;vue-router\u0026#39; import Vue from \u0026#39;vue\u0026#39; //1. 通过vue.use(插件), 安装插件 Vue.use(VueRouter) //2. 创建VueRouter对象 const routes = [ ] const router = new VueRouter({ //配置路由和组件之间的应用关系 routes }) //3. 将router对象传入到Vue实例中 export default router 使用vue-rounter的步骤 创建路由组件 配置路由映射:组件和路径的映射关系 使用路由:通过 和 路由的默认路径 const routes = { path: \u0026#39;\u0026#39;, redirect: \u0026#39;/home\u0026#39; } 默认的hash模式,改为history模式,在index.js文件中修改 const router = new VueRouter({ //配置路由和组件之间的应用关系 routes, // 默认路由方式为hash,一下修改为h5的history模式 mode: \u0026#39;history\u0026#39; }) rounter-link属性问题 tag:tag可以指定之后渲染成什么组件,比如:tag=\u0026lsquo;li\u0026rsquo; replace:replace不会留下history记录,所以指定replace的情况下,后退键返回不能返回到上一个界面中 LinkActiveCalss:当对应的路由匹配成功时,会自动给当前元素设置一个rounter-link-active的class,设置LinkActiveClass可以修改默认的名称 动态路由 添加相关组件,创建组件如User组件 在index.js文件中添加该组件信息 在App.vue中使用该组件动态路由 路由的懒加载 路由懒加载的作用 主要作用就是将路由对应的组件打包成一个个的js代码块;\n只有在这个路由被访问到的时候,才加载对应的组件\n路由懒加载的方式 结合vue的异步组件和webpack的代码\nAMD写法:\nconst About = resolve =\u0026gt; require(['../components/About.vue],resolve)\nES6中,更加简单的写法来组织vue异步组件和webpack的代码分割\nconst Home = () =\u0026gt; import ('../components/Home.vue)\nvue-rounter的嵌套路由 什么是嵌套路由? 比如在Home页面中,我们希望通过/home/news 和 /home/message访问一些内容 一个路径映射一个组件,访问这两个组件也会分别渲染两个组件 实现步骤: 创建对应的子组件,并且在路由映射中配置对应的子路由 在组件内部使用标签 vue-rounter参数传递 参数传递的方式:params和query params的类型 配置路由格式: /router/:id 传递的方式: 在path后面跟上对应的值 传递后形成的路径:/router/123, /router/abc query类型 配置路由格式:/router, 也就是普通格式 传递方式:对象中使用query的key作为传递方式 传递后形成的路径: /router?id=123, /router?id=abc $rounter 和 rounte的区别 router: router是VueRouter的一个对象，通过Vue.use(VueRouter)和VueRouter构造函数得到一个router的实例对象，这个对象中是一个全局的对象，他包含了所有的路由包含了许多关键的对象和属性 **route: **route是一个跳转的路由对象，每一个路由都会有一个route对象，是一个局部的对象，可以获取对应的name,path,params,query等 vue-rounter导航守卫 什么是导航守卫? vue-router提供的导航守卫主要用来监听监听路由的进入和离开 vue-router 提供了beforeEach和afterEach的钩子函数,他们会在路由即将改变前和改变后触发 使用: 分类: 全局守卫 路由独享的守卫 组件内的守卫 参数: to: 即将要进入的目标的路由信息 from: 当前导航即将要离开的路由对象 next: 调用该方法,才能进入下一钩子 tips: 如果是后置钩子,也就是afterEach, 不需要主动去调用next()函数\nrouter.beforeEach((to, from, next) =\u0026gt; { //从from跳转到to document.title = to.matched[0].meta.title next() }) keep-alive keep-alive是vue内置的一个组件,可以使被包含的组件保留状态,或避免重新渲染\n两个重要属性:\ninclude - 字符串或正则表达式,只有匹配的组件会被缓存\nexclude - 字符串或者正则表达式,任何匹配的组件都不会被缓存\nrounter-view也是一个组件,如果直接被包在keep-alive里面,所有路径匹配到视图组件都会被缓存\nvuex state 单一状态树\ngetters 基本使用: 相当于computed计算属性\n参数和传入对象 pow(state){ return state.counter * state.counter }, more20stu(state){ return state.students.filter(s =\u0026gt; s.age \u0026gt; 20) }, more20stuLength(state, getters){ return getters.more20stu.length }, moreAge(state){ // return function (age){ // return state.students.filter(s =\u0026gt; s.age \u0026gt; age) // } return age =\u0026gt; { return state.students.filter(s =\u0026gt; s.age \u0026gt; age) } } mutation 主要包括两部分: 字符串的事件类型(type);\n一个回调函数(hander),该回调函数的第一个参数就是state\n在通过mutation更新数据的时候,希望携带的额外的参数被称为mutation的载荷(PayLoad) 提交风格 this.$store.commit({ type: \u0026#39;change\u0026#39;, count: 20 }) change(state,payload){ state.count = payload.count } 响应规则 提前在store中初始化好所需的属性 当给store中的对象添加新属性时,使用下面的方式: 使用Vue.set(obj, \u0026rsquo;new Prop\u0026rsquo; , 123) ,可以添加到响应式系统中 用新对象给就对象赋值 当给store中的对象删除属性时,使用 Vue.delete(obj, 'prop') 常量类型 mutation-types.js\n同步函数 action:用来代替mutation进行异步操作 actions:{ aUpdateInfo(context, payload) { return new Promise((resolve, reject) =\u0026gt; { setTimeout(() =\u0026gt; { context.commit(\u0026#39;updateInfo\u0026#39;); console.log(payload); resolve(\u0026#39;1111111\u0026#39;) }, 1000) }) } }, update(){ this.$store .dispatch(\u0026#39;aUpdateInfo\u0026#39;, \u0026#39;我是携带的信息\u0026#39;) .then(res =\u0026gt; { console.log(\u0026#39;里面完成了提交\u0026#39;); console.log(res); }) } module vue使用单一状态树,就意味着很多状态都会交给vuex管理,当应用变得复杂的时候,store就变得相当臃肿,所以vuex允许将store分割成模块(module),而每个模块都可以拥有自己的state,mutations,actions等\n网络封装(axios) 特点 在浏览器发送HMLHttpRequest请求\n在node.js中发送http\n支持Promise API\n拦截请求和响应\n转换请求和响应\n使用 多种请求方式 axios(config) axios.request(config) axios.get(url[,config]) axios.delete(url,[config]) axios.head(url,[config]) axios.post(url,[,data[,config]]) axios.put(url,[,data[,config]]) axios.patch(url,[,data[,config]]) 发送并发请求 使用axios.all,可以放入多个请求的数组 axios.all[]返回的结果是一个数组,使用axios.spread可将数组[res1,res2]展开为res1,res2 全局配置 请求地址 : url:\u0026rsquo;/user 请求类型 : methods: \u0026lsquo;get\u0026rsquo; 请求根路径 : baseURL:\u0026lsquo;http://www.mt.com/api' 请求前的数据处理 : transformRequest: [function(data){}], 请求后的数据处理 : transformRequest:[function(data){}] 自定义的请求头 : header:{\u0026lsquo;X-Request-With\u0026rsquo;:\u0026lsquo;XMLHttprequest\u0026rsquo;}, URL查询对象 : params:{id:12} 查询对象序列化函数 request body(请求体) 超时设置 跨域是否带Token 自定义请求处理 身份验证信息 相应的数据格式 axios实例 const instance1 = axios.create({ baseURL: \u0026#39;http://123.207.32.32:8000\u0026#39;, timeout: 5000 }) instance1({ url: \u0026#39;/home/multidata\u0026#39; }).then(res =\u0026gt; { console.log(res); }) VUE补充 标签 作用: 可以动态的绑定组件, 根据数据的不同更换不同的组件\n\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34; src=\u0026#34;../assets/js/vue.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;title\u0026gt;component-4\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;h1\u0026gt;component-4\u0026lt;/h1\u0026gt; \u0026lt;hr\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; // 绑定 who 数据 \u0026lt;component v-bind:is=\u0026#34;who\u0026#34;\u0026gt;\u0026lt;/component\u0026gt; \u0026lt;button @click=\u0026#34;changeComponent\u0026#34;\u0026gt;changeComponent\u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; // 定义三个不同的组件 var componentA={ template:`\u0026lt;div style=\u0026#34;color:red;\u0026#34;\u0026gt;I\u0026#39;m componentA\u0026lt;/div\u0026gt;` } var componentB={ template:`\u0026lt;div style=\u0026#34;color:green;\u0026#34;\u0026gt;I\u0026#39;m componentB\u0026lt;/div\u0026gt;` } var componentC={ template:`\u0026lt;div style=\u0026#34;color:pink;\u0026#34;\u0026gt;I\u0026#39;m componentC\u0026lt;/div\u0026gt;` } var app=new Vue({ el:\u0026#39;#app\u0026#39;, data:{ who:\u0026#39;componentA\u0026#39; }, components:{ // 注册三个组件 \u0026#34;componentA\u0026#34;:componentA, \u0026#34;componentB\u0026#34;:componentB, \u0026#34;componentC\u0026#34;:componentC, }, methods:{ changeComponent:function(){ if(this.who==\u0026#39;componentA\u0026#39;){ this.who=\u0026#39;componentB\u0026#39;; }else if(this.who==\u0026#39;componentB\u0026#39;){ this.who=\u0026#39;componentC\u0026#39;; }else{ this.who=\u0026#39;componentA\u0026#39;; } } } }) \u0026lt;/script\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; ","permalink":"https://sirius00.github.io/posts/tech/vue2%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","summary":"Vue2学习笔记 认识vue 渐进式框架,什么是渐进式? 渐进式意味着你可以将vue作为你应用的一部分嵌入其中 vue特点 解耦视图和数据 可复用的组件 前端路由技术 状态管理 虚拟DOM 安装 响应式开发 生命周期 webstorm 模板功能 基础知识 插值操作 mustache语法 \u0026lt;span\u0026gt;Message: {{ msg }}\u0026lt;/span\u0026gt; v-once语法 \u0026lt;span v-once\u0026g","title":"Vue2学习笔记"},{"content":"全局文件 pages.json页面路由 ​\nmainfest.json应用配置 uni.scss文件 ​\t作用:为了方便整体控制应用的风格。比如按钮颜色、边框风格，uni.scss文件里预置了一批scss变量预置\nmain.js文件 ​\t项目的入口文件,主要作用是初始化vue实例并使用需要的插件\nunpackage ​\t打包目录\n页面 页面生命周期 onLoad: ​\t监听页面加载,其参数为上个页面传递的数据,参数类型为object\nonShow: ​\t监听页面显示.页面每次出现在屏幕上都出发\nonReady: ​\t监听页面初次渲染完成\nonHide: 监听页面隐藏 onUnload: ​\t监听页面卸载\nonPullDownRefresh: ​\t监听用户下拉刷新\n两种方式开启下拉刷新:\n需要在pages.json 里,找到当前页面的pages节点,并在style选项中开启 enablePullDownRefresh\n通过调用uni.startPullDownRefresh方法来开启下拉刷新\n// 仅做示例，实际开发中延时根据需求来使用。 export default { data() { return { text: \u0026#39;uni-app\u0026#39; } }, onLoad: function (options) { setTimeout(function () { console.log(\u0026#39;start pulldown\u0026#39;); }, 1000); uni.startPullDownRefresh(); }, onPullDownRefresh() { console.log(\u0026#39;refresh\u0026#39;); setTimeout(function () { uni.stopPullDownRefresh(); }, 1000); } } 页面调用接口 页面通讯 父传子 父组件通过零v-bind绑定数据\n子组件通过props接收来自外界传递到组件内部的值\n子传父 通过$emit触发事件进行传递参数\n为子组件methods添加emit触发事件\n设置参数:触发事件的名称, 所传参数 this.$emit('myEven', this.num) 父组件接收该事件\n在父组件相应的子组件位置接收该触发事件\n\u0026lt;test v-if=\u0026quot;flag\u0026quot; :title=\u0026quot;title\u0026quot; @myEven=\u0026quot;getNum\u0026quot;\u0026gt;\u0026lt;/test\u0026gt;\n在父组件methods中添加相应的方法 (getNum)\n兄弟组件 uni.$emit(eventName,OBJECT) ​\t触发全局的自定义事件.附加参数都会传给监听器回调\nuni.$on(eventName,callback) ​\t监听全局的自定义事件, 事件可以由uni.emit触发, 回调函数会接收所有传入事件触发函数的额外参数\n​\t被修改界面添加监听\ncreated() { uni.$on(\u0026#39;update\u0026#39;, num =\u0026gt; { this.num += num }) } ​\t修改数据界面添加事件\nmethods: { addNum() { uni.$emit(\u0026#39;update\u0026#39;,this.num) } } uni.$once(eventName,callback) ​\t监听全局的自定义事件, 但是只触发一次,在触发之后移除监听器\nuni.$off([eventName, callback]) ​\t移除全局自定义事件监听器\n页面路由跳转 页面路由跳转方式: navigator组件跳转 调用API跳转: 路由方式 页面栈表现 触发时机 打开新页面 新页面入栈 调用 API uni.navigateTo 、使用组件 \u0026lt;navigator open-type=\u0026quot;navigaator\u0026quot;\u0026gt; 页面重定向 当前页面出栈，新页面入栈 调用 API uni.redirectTo 、使用组件 \u0026lt;navigator open-type=\u0026quot;redirectTo\u0026quot;\u0026gt; 页面返回 页面不断出栈，直到目标返回页 调用 API uni.navigateBack 、使用组件 \u0026lt;navigator open-type=\u0026quot;navigatorBack\u0026quot;\u0026gt; 、用户按左上角返回按钮、安卓用户点击物理back按键 Tab 切换 页面全部出栈，只留下新的 Tab 页面 调用 API uni.switchTab 、使用组件 \u0026lt;navigator open-type=\u0026quot;switchTab\u0026quot;\u0026gt; 、用户切换 Tab 重加载 页面全部出栈，只留下新的页面 调用 API uni.reLaunch 、使用组件 \u0026lt;navigator open-type=\u0026quot;reLaunch\u0026quot;\u0026gt; 组件 内置组件 视图容器 基础内容 表单组件 路由及页面跳转 ​\t[页面路由跳转](# 页面路由跳转)\n媒体组件 画布 canvas\n组件的生命周期 beforeCreate: ​\t在实例初始化之前被调用\ncreated: ​\t在实例创建完成后被立即调用\nbeforeMount: ​\t在挂载开始之前被立即调用\nmounted: ​\t挂载到实例上去之后调用\nbeforeUpdate: ​\t数据更新之前调用,发生在虚拟DOM打补丁之前\nupdate: ​\t由于数据更改导致的虚拟DOM重新渲染和打补丁,在这之后会调用该钩子\nbeforeDestroy: ​\t实例销毁之前调用\ndestroyed: ​\tVue实例销毁之后调用.调用后,vue实例指示的所有东西都会解绑,所有的事件监听器会被移除,所有的子实例也会被销毁\nAPI 绘画(canvas) 配置网路请求 由于平台的限制,小程序项目中不支持使用axios, 而且原生的wx.request(), API功能较为简单,不支持拦截器等全局定制的功能.因此建议在uni-app项目中使用 @escook/request-miniprogram 第三方包发起网络数据请求\n官方文档 @escook/request-miniprogram\n在项目的 main.js 文件中,通过如下方式进行配置:\nimport { $http } from \u0026#39;@escook/request-miniprogram\u0026#39; // 在 uni-app 项目中，可以把 $http 挂载到 uni 顶级对象之上，方便全局调用 uni.$http = $http // 请求的根路径 $http.baseUrl = \u0026#39;https://wwww.xxxxxxxx.com\u0026#39; // 请求拦截器 $http.beforeRequest = function (options) { uni.showLoading({ title: \u0026#34;数据加载中...\u0026#34; }) } // 响应拦截器 $http.afterRequest = function () { uni.hideLoading() } 使用:\n//获取轮播图数据 async getSwiperList() { // 1、 发起请求（请求返回的是一个promise对象，我们可以用async和await来做优化） const { data: res } = await uni.$http.get(\u0026#39;/api/xxx/xxx/xxx/swiperData\u0026#39;) console.log(\u0026#39;查看请求的结果=\u0026gt;\u0026gt;\u0026#39;,res); // 2、 请求失败 if (res.meta.status !== 200) { return uni.showToast({ title: \u0026#39;数据请求失败！\u0026#39;, duration: 1500, icon: \u0026#39;none\u0026#39;, }) } // 3、 请求成功，为 data 中的数据赋值 this.swiperList = res.message; }, tips: uni-app在使用v-for时block和view的使用区别: 使用view自带换行效果\n使用block时,不带换行效果\n关于uni-app中使用canvas,在H5不显示问题 需要注意的问题: 组件嵌套,在子组件中不能使用canvas ,也不是说不能,只能说使用了也没用,H5中显示无果,小程序一样.(我在uniapp社区提出这个bug ,但是我看有人在今年的6.7月份也提出过,但至今为止没有解决这个问题) 在H5中 出现canvas闪烁的问题 ,就一定要用异步去显示canvas, 绘制canvas 时 得用uniapp 中的draw()去绘制,不然 不会显示(原生一般直接填充就完事了) 一定要在onReady函数中进行实例化canvas并且绘制 \u0026lt;template\u0026gt; \u0026lt;view class=\u0026#34;\u0026#34;\u0026gt; \u0026lt;view style=\u0026#34;margin:0 auto;width: 200px;padding-left: 10px;\u0026#34;\u0026gt; \u0026lt;canvas style=\u0026#34;width: 200px;; height: 200px;border: #007AFF solid 1rpx;\u0026#34; canvas-id=\u0026#34;myCanvas\u0026#34; id=\u0026#34;myCanvas\u0026#34;\u0026gt;\u0026lt;/canvas\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; export default { onReady() { this.initCanvas() }, data() { return { wendu:16 } }, methods: { /*初始化画布*/ initCanvas() { const ctx = uni.createCanvasContext(\u0026#39;myCanvas\u0026#39;,this) ctx.beginPath(); ctx.arc(100,100,60,0.7*Math.PI,0.30*Math.PI); ctx.createLinearGradient(0,0,170,0); /* 渐变 */ const grd=ctx.createLinearGradient(0,0,170,0); grd.addColorStop(\u0026#34;0.7\u0026#34;,\u0026#34;#09C4D5\u0026#34;); grd.addColorStop(1,\u0026#34;#07D2B8\u0026#34;); ctx.strokeStyle = grd; ctx.lineWidth = 8; /* 字体 */ ctx.font=\u0026#34;40px Arial\u0026#34;;\t//设置字体大小 ctx.fillStyle = \u0026#39;#09C4D5\u0026#39;;//fillStyle填充颜色 ctx.fillText(\u0026#34;16\u0026#34;,73,110); //fillText(\u0026#34;字体\u0026#34;,x,y) ctx.font=\u0026#34;20px Arial\u0026#34;\tctx.fillStyle = \u0026#39;gray\u0026#39;; ctx.fillText(\u0026#34;℃\u0026#34;,115,88); ctx.font=\u0026#34;12px Arial\u0026#34; ctx.fillStyle = \u0026#39;gray\u0026#39;; ctx.fillText(\u0026#34;室内温度\u0026#34;,77,130); /* 阴影 */ ctx.shadowBlur=2; ctx.shadowColor=\u0026#34;#09C4D5\u0026#34;; setTimeout(function(){\t//必须延迟执行 不然H5不显示 ctx.stroke(); ctx.draw()\t//必须加上 uniapp 没这儿玩意儿 显示不出来不比原生 不加可以显示 },200) }, }, \u0026lt;/script\u0026gt; uni-app中使用vuex uni-app中阻止事件冒泡 开发小程序时的 注意事项 @click.stop来做事件冒泡没有作用。需要把@click.stop改成@tap.stop就可以实现了\nuni-app点击子元素出发父元素事件 \u0026lt;view class=\u0026#34;bgFixedBack\u0026#34; id=\u0026#34;bgFixedBack\u0026#34; @click=\u0026#34;closeModalLight\u0026#34;\u0026gt;\t\u0026lt;view id=\u0026#39;bgWhite\u0026#39; ref=\u0026#39;bgWhite\u0026#39; class=\u0026#34;bgWhite\u0026#34; @click.stop=\u0026#39;!closeModalLight\u0026#39;\u0026gt; \u0026lt;modal-header :title=\u0026#39;title\u0026#39;\u0026gt;\u0026lt;/modal-header\u0026gt; \u0026lt;view class=\u0026#34;mainContent\u0026#34;\u0026gt; 啊哈哈哈 \u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; \u0026lt;/view\u0026gt; 父元素关闭弹框事件： @click=“closeModalLight”\n子元素点击事件： ① @click.stop=‘!closeModalLight’\n②@click.stop=“() =\u0026gt; {}”\n③@click.native.stop=“() =\u0026gt; {}”\n事件映射表 事件映射官方文档\n// 事件映射表，左侧为 WEB 事件，右侧为 ``uni-app`` 对应事件 { click: \u0026#39;tap\u0026#39;, touchstart: \u0026#39;touchstart\u0026#39;, touchmove: \u0026#39;touchmove\u0026#39;, touchcancel: \u0026#39;touchcancel\u0026#39;, touchend: \u0026#39;touchend\u0026#39;, tap: \u0026#39;tap\u0026#39;, longtap: \u0026#39;longtap\u0026#39;, //推荐使用longpress代替 input: \u0026#39;input\u0026#39;, change: \u0026#39;change\u0026#39;, submit: \u0026#39;submit\u0026#39;, blur: \u0026#39;blur\u0026#39;, focus: \u0026#39;focus\u0026#39;, reset: \u0026#39;reset\u0026#39;, confirm: \u0026#39;confirm\u0026#39;, columnchange: \u0026#39;columnchange\u0026#39;, linechange: \u0026#39;linechange\u0026#39;, error: \u0026#39;error\u0026#39;, scrolltoupper: \u0026#39;scrolltoupper\u0026#39;, scrolltolower: \u0026#39;scrolltolower\u0026#39;, scroll: \u0026#39;scroll\u0026#39; } ","permalink":"https://sirius00.github.io/posts/tech/uniapp%E7%9A%84%E4%BD%BF%E7%94%A8/","summary":"全局文件 pages.json页面路由 ​ mainfest.json应用配置 uni.scss文件 ​ 作用:为了方便整体控制应用的风格。比如按钮颜色、边框风格，uni.scss文件里预置了一批scss变量预置 main.js文件 ​ 项目的入口文件,主要作用是初始化vue实例并使用需要的插件 unpackage","title":"Uniapp的使用"},{"content":"安装django 安装django ：pip3 install django==2.2.12\n检查安装的django版本：python -m django \u0026ndash;version\n创建项目\ndjango-amdin startproject mysite\n启动服务\n1、进入项目文件夹\n2、python3 manage.py runserver\n改变端口号\npython manage.py runserver 端口号\n项目结构 manage.py: 一个让你用各种方式管理 Django 项目的命令行工具\nrunserver：启动服务 startapp：创建应用 migrate：数据库迁移 python3 manage.py：查看所有命令 里面一层的 mysite/ 目录包含你的项目，它是一个纯 Python 包。它的名字就是当你引用它内部任何东西时需要用到的 Python 包名。 (比如 mysite.urls).\nmysite/__init__.py：一个空文件，告诉 Python 这个目录应该被认为是一个 Python 包。\nmysite/settings.py：Django 项目的配置文件。\n公有配置、自定义配置\nimport os 项目绝对路径 BASE_DIR = os.path.dirname(os.path.dirname(os.path.abspath(__file__))) 项目启动模式 DEBUG = True true 调试模式 false 上线模式 过滤请求头Host头 ALLOWED_HOSTS = [] # Application definition INSTALLED_APPS = [ \u0026#39;django.contrib.admin\u0026#39;, \u0026#39;django.contrib.auth\u0026#39;, \u0026#39;django.contrib.contenttypes\u0026#39;, \u0026#39;django.contrib.sessions\u0026#39;, \u0026#39;django.contrib.messages\u0026#39;, \u0026#39;django.contrib.staticfiles\u0026#39;, ] 中间件 MIDDLEWARE = [ ] DATABASES = { \u0026#39;default\u0026#39;: { \u0026#39;ENGINE\u0026#39;: \u0026#39;django.db.backends.sqlite3\u0026#39;, \u0026#39;NAME\u0026#39;: os.path.join(BASE_DIR, \u0026#39;db.sqlite3\u0026#39;), } } 页面显示语言 zh-hans LANGUAGE_CODE = \u0026#39;en-us\u0026#39; 时区 Asia/Shanghai TIME_ZONE = \u0026#39;UTC\u0026#39; USE_I18N = True USE_L10N = True USE_TZ = True # Static files (CSS, JavaScript, Images) # https://docs.djangoproject.com/en/2.2/howto/static-files/ STATIC_URL = \u0026#39;/static/\u0026#39; mysite/urls.py：Django 项目的 URL 声明，就像你网站的“目录”。\nmysite/wsgi.py：作为你的项目的运行在 WSGI 兼容的Web服务器上的入口。\nURL和视图函数 样例 #file：\u0026lt;项目同名文件夹下\u0026gt;/views.py from django.http import HttpResponse def page1_view(request): html = \u0026#34;\u0026lt;h1\u0026gt;这是第一个页面\u0026lt;h1\u0026gt;\u0026#34; return HttpResponse(html) 同时配置url文件 添加path路径 路由配置 样例 setting.py 文件中的 root_urlconf 指定了主路由配置列表urlpatterns的文件位置 path函数 导入 - from django.urls import path 语法 - path(route,views,name-None) 参数： 1、route：字符串型，匹配的请求路径 2、views：指定路径所对应的视图处理函数的名称 3、name：为地址别名，在模板中地址反向解析时使用 path转换器 语法：\u0026lt;转换器类型：自定义名\u0026gt; 作用：若转换器类型匹配到对应类型的数据，则将数据按照关键字传参的方式传递给视图函数 例子：path(\u0026#39;page/\u0026lt;int:page\u0026gt;\u0026#39;,views.xxx) re_path()函数 在URL的匹配过程中可以使用正则表达式进行精确匹配\n请求和响应 请求是指浏览器端通过HTTP协议发送给服务器端的数据\npath_info：url字符串\nmethod：字符串，表示HTTP请求方法，常用值：“GET”、“POST”\nGET：QUeryDict查询字典的对象，包含get请求方式的所有数据\nPOST：QUeryDict查询字典的对象，包含post请求方式的所有数据\nFILES：类似于字典的对象，包含所有的上传文件信息\ncookies：python字典，包含所有的cookies，键和值都为字符串\nsession：类似于字典的对象，表示当前会话\nbody：字符串，请求体的内容\nscheme：\nrequest.get_full_path():\nRequest.META:请求中的元数据（消息头）\n响应是指服务器端接收到请求之后做相应的处理在回复给浏览器端的数据\n响应状态码 200：请求成功 301：永久重定向-资源（网页等）被永久转移到其他的URL 302：临时重定向 404：请求的资源（网页等）不存在 500：内部服务器错误 django的响应对象 POST和GET请求 处理逻辑\nif request.requestmethod == \u0026#39;GET\u0026#39;: 处理GET请求 else request.method == \u0026#39;POST\u0026#39;: 处理POST请求 else: 其他请求 报错403,取消csrf验证\n禁止掉settings.py中middleware中的CrfsViewsMiddleWare的的中间件\nDjango设计模式和模板层 设计模式 MTV\n模板层 什么是模版? 是可以根据字典数据动态变化的html网页 可以根据视图中传递的字典数据动态生成相应的html网页 模板配置 创建模板文件夹\u0026lt;项目名\u0026gt;/template 在settings.py中templates配置项 BACKEND:制定模板的引擎 DIRS:模板的搜索目录 只需要修改（设置DIRS - ‘DIRS’：[os.path.join(BASE_DIR,\u0026rsquo;templates\u0026rsquo;)],) APP_DIRS:是否要在应用中的template文件夹中搜索模板文件 OPTIONS：有关模板的选项 模板的加载方式 通过loader获取模板,通过HttpResponse进行响应\n在views文件中\ndef test_html(request): from django.temlates import loader t = loader.get_template(\u0026#34;模板文件名\u0026#34;) html = t.render(字典数据) //转换成字符串 return HttpResponse(html) 在templates文件夹中创建文件\n在urls.py文件中添加路径\n使用render()直接加载并响应模板\n在视图函数中\nfrom django.shortcuts import render return render(request,\u0026#39;模板名\u0026#39;,字典数据) 视图层和模板层之间的交互 视图函数中可以将python变量封装到字典中传递到模板层\ndef xx_view(request): dic = { \u0026#34;变量1\u0026#34;:\u0026#34;值1\u0026#34;, \u0026#34;变量2\u0026#34;:\u0026#34;值2\u0026#34;, } return render(request,\u0026#39;xx.html\u0026#39;,dic) 模板中,可以使用{{变量名}}的语法调用视图传进来\n模板层变量和标签 模板层变量\n能传递到模板中的数据类型 str - 字符串 list - 数组 dict - 字典 obj - 类实例化对象 int - 整型 tuple - 元组 func - 方法 在模板中使用变量语法 {{变量名}} {{变量名.index}} {{变量名.key}} {{对象.方法}} {{函数名}} 模板标签\n标签语法\n{% 标签 %} ... {% 结束标签 %} 模板层 - 过滤器和继承 过滤器\n继承\n在父模板中\n定义父模板中的块block标签 标识出安歇在子模块是允许被修改的 block标签:在父模块中定义,可以在子模块中覆盖 在子模块中\n继承模板extends标签(写在模板文件第一行)\n{%extends \u0026#39;base.html\u0026#39;%} 子模板 重写父模块中的内容模块\n{% block block_name%} 子模板用来覆盖父模板中 block_name块的内容 {% endblock block_name %} URL反向解析 url反向解析是指在视图或模板中,用path定义的名臣来动态查找或计算出相应的路由\n路由转换器 https://www.cnblogs.com/wanglan/p/11639611.html\npath函数的语法 path(route,views,name = \u0026#34;别名\u0026#34;) path(\u0026#39;page\u0026#39;,views.page_view,name=\u0026#34;page_url\u0026#34;) 根据path中的\u0026rsquo;name=\u0026lsquo;关键字传参给url确定了个唯一确定的名字,在模板或视图中,可以通过这个名字反向推断出url信息\n模板中 - 通过url标签实现地址的反向解析 {% url \u0026#39;别名\u0026#39; %} {% url \u0026#39;别名\u0026#39; \u0026#39;参数值1\u0026#39; \u0026#39;参数值2\u0026#39; %} ex: {% url \u0026#39;pagen\u0026#39; \u0026#39;400\u0026#39; %} {% url \u0026#39;person\u0026#39; age=\u0026#39;18\u0026#39; name=\u0026#39;gxn\u0026#39; %} 在视图函数中 -\u0026gt;可调用django中的reverse方法进行反向解析 from django.urls import reverse reverse(\u0026#39;别名\u0026#39;,args=[],kwargs={}) 静态文件 静态文件配置 - settings.py中 配置静态文件访问路径\n通过哪个url地址查找静态文件\nstatic_url = \u0026lsquo;/static/\u0026rsquo;\n说明\n指定访问静态文件时需要通过/static/xxx或http://127.0.0.1:8000/static/xxx[xxx 表示具体文件位置]\n配置静态文件的存储路径STATICFILES_DIRS\n保存的是静态文件在服务器端的存储位置\nSTATICFILES_DIRS= ( os.path.join(BASE_DIR,\u0026#34;static\u0026#34;), ) 模板中访问静态文件 - img标签为例 更动态的写法\n通过{% static %}标签访问静态文件\n加载static - {% load static %}\n使用使用静态资源 \u0026ndash; {% static \u0026lsquo;静态资源路径\u0026rsquo; %}\n样例\n\u0026lt;img src=\u0026#34;{% static \u0026#39;image/lena.jpg\u0026#39; %}\u0026#34;\u0026gt; Django应用和分布式路由 应用 应用是在django项目中是一个独立的业务模块,可以包含自己的路由,视图,模板,模型\n创建应用 使用manage.py中的子命令startapp创建应用文件夹\npython3 manage.py startapp music 在settings.py的INSTALLED_APPS列表中配置安装此应用\n分布式路由 Django中,主路由配置文件(urls.py)可以不处理用户具体路由,主路由配置文件可以做请求的分发(分布式请求处理).具体的请求可以由各自的应用来进行处理\n主路由中调用include函数\n语法 : include(\u0026lsquo;app名字.url模块名\u0026rsquo;)\n*作用 :*用于将当前路由转到各个应用的路由配置文件的urlpatterns进行分布式处理\npath(\u0026#39;music/\u0026#39;,include(\u0026#39;music.urls\u0026#39;)) 应用下配置urls.py\n应用下手动创建urls.py\n内容结构同主路由完全一样\n模型层 模型层 - 负责跟数据库之间进行通信 什么是模型 模型是一个类,由django.db.models.MODEL派生出的子类 一个模型类代表数据库中的一张数据表 模型类中每一个类属性都代表数据库中的一个字段 模型是数据交互的接口,表示和操作数据库的方法和方式 模型类 - 创建 from django.db import models class 模型类名(models.Model): 字段名 = models.字段类型(字段选项) Django配置mysql 安装mysqlclient 创建数据库\n进入mysql数据库 执行\ncreate datebase 数据库名 default charset utf8; 通常数据库名称和项目名保持一致 settings.py中配置数据库\nENGINE - 指定数据库存储引擎 \u0026#39;django.db.backends.mysql\u0026#39; \u0026#39;django.db.backends.sqlite3\u0026#39; \u0026#39;django.db.backends.oracle\u0026#39; \u0026#39;django.db.backends.postgresql\u0026#39; NAME-指定要连接的数据库名字 USER-指定登录到数据库的用户名 PASSWORD-数据库的密码 HOST/PORT-连接数据库的IP和端口 django数据库从sqlite3切换到mysql 切换数据库到mysql\n数据库迁移 迁移是django同步您对模型所做的更改(添加字段,删除模型等)到您的数据库模式的方式\n生成迁移文件\n执行\npython3 manage.py makemigrations 将应用下的models.py文件生成一个中间文件,,并保存在migrations文件夹下\n执行迁移脚本程序\n执行\npython3 manage.py migrate 执行迁移程序实现迁移,将每个应用下的migrations目录中的中间文件同步回数据库\nORM ORM框架 定义:ORM即对象关系映射,它允许你实用类和对象对数据库进行操作,从而避免通过SQL语句操作数据库\n作用:\n建立模型类和表之间的对应关系,允许我们通过面向对象的方式来操作数据库 根据设计的模型类生成数据库的表格 通过简单的配置就可以进行数据库的切换 对应关系\nORM DB 类 数据表 对象 数据行 属性 字段 ORM - 基础字段及选项 创建模型类流程 创建应用\n在应用的models.py中编写模型类\nfrom django.db import models calss 模型类名(models.Model): 字段名 = models.字段类型(字段选项) 迁移同步 makemigration \u0026amp; migrate\n任何关于表结构的修改,务必在对应模型类上修改\n例如:为bookstore_book表 添加一个名为info的字段 varchar(100)\n步骤:\n模型类中添加对应类属性 执行数据库迁移 模型类 - 字段类型 BooleanField()\n数据库类型:tinyint(1)\n编程语言中:使用True或False来表示值\n在数据库中:使用1或0来表示具体的值\nCharfield()\n数据库类型:varchar\ntips:必须要指定max_length参数值\nDateField()\n数据库类型:date\n作用:表示日期\n参数:\nauto_now:每次保存对象时,自动设置该字段为当前时间(True/False) suto_now_add:当对象第一次被创建时自动设置当前时间(True/False) default:设置当前时间(取值:字符串时间格式:2019-6-1) DateTimeField()\n数据库类型:datetime(6)\n作用:表示日期和时间\n参数同DateField\nFloatField()\n数据库类型:double\n编程语言中和数据库中都使用小数表示\nDecimalField()\n数据库类型:decimal(x,y)\n编程语言中:使用小数点表示该列的值\n在数据库中:使用小数\n参数:\nmac_digits:位数总数,包括小数点后的位数.该值必须大于等于decimal_place\ndecimal_place:小数点后的数字数量\nEmailField()\n数据库类型:varchar\n编程语言和数据库中使用字符串\nIntergerField()\n数据库类型:int\n编程语言和数据库中使用整数\nImageField()\n数据库类型:varchar(100)\n作用:在数据库中为了保存图片的路径\n编程语言和数据库中使用字符串\nTextField()\n数据库类型:longtext\n作用:表示不定长的字符数据\n模型类 - 字段选项 字段类型,指定创建的列的额外信息\n允许出现多个字段选项,多个选项之间使用,隔开\nprimary_key\n如果设置为True,表示该列为主键,如果指定一个字段为主键,则此数据库表不会创建id字段\nblank\n设置为True时,字段可以为空.设置False时,字段是必须填写的\nnull\nTrue,表示该列允许为空\nFalse,如果此项为False,建议加default选项来设置默认值\ndefault\n设置所在列的默认值\ndb_index\nTrue,表示为该列增加索引\nunique\nTrue,表示该字段在数据库中的值必须是唯一\ndb_column\n指定列的名称,如果不指定的话采用属性名来作为列名\nverbose_name\n设置此字段在admin界面上的显示名称\n例如:\nname = models.CharField(max_length = 30 , unique = True, null = False, db_index = True) 模型类 - Meta类 mate类 - 定义 使用内部Mate类 来给模型赋予属性,Mate类下有很多内建的类属性,可对模型类做一些控制\nfrom django.db import models class Book(models.Model): title = models.CharField(\u0026#34;书名\u0026#34;,max_length=50,default=\u0026#39;\u0026#39;) price = models.DecimalField(\u0026#39;定价\u0026#39;,max_digits=7,decimal_place=2,default=0.0) class Mate: 1.db_table= \u0026#39;book\u0026#39; #可改变当前模型类对应的表名(设置后须立即更新数据库) 2.verbose_name = \u0026#39;单数名\u0026#39; #给模型对象一个单数名称,用于显示在/admin界面 3verbose_name_plural = \u0026#39;复数名\u0026#39; #该对象复数形式显示在/admin界面 ORM - 基本操作 - 创建数据 常见问题处理 问题一\n![iShot2022-01-07 13.13.28](/Users/cobb/Documents/屏幕截图/iShot2022-01-07 13.13.28.png)\n错误原因:\n当对模型类添加一个新字段时可出现的错误,添加新字段后,数据库不知道原来已有数据对于新建字段该如何赋值,所以新增字段时,务必添加default值\n解决办法:\n进入到shell中,手动输入一个默认值 退出当前生成迁移文件过程,自己去修改models.py,新增加一个\u0026rsquo;default=xxx\u0026rsquo;的缺省值(推荐) 问题二\n数据库的迁移文件混乱\n原因:\n数据库中django_migration表记录了migrate的\u0026rsquo;全过程\u0026rsquo;,项目个应用中的migrate文件应与之对应,否则migrate会出现错误\n解决:\n删除 所有migration里所有000?_ xxx.py ( _ init _.py除外) 删除 数据库 重新创建数据库 重新生成mogrations里所有的000?_xxx.py 重新更新数据库 ORM - 操作 基本操作包括增删改查,即(CRUD操作)\nCRUD是指在做计算处理时的增加(create),读取操作(Read),更新(update)和删除(delete)\nORM CRUD 核心 -\u0026gt; 模型类.管理器对象\n管理器对象\n​\t每个继承自models.Model的模型类,都会有objects对象被同样继承下来,这个对象叫 做管理其对象\n​\t数据库的增删改查可以通过模型的管理器来实现\nclass MyModel(models.Model): ... MyModel.objects.create(...) #objects是管理器对象 创建数据 创建数据中每一条记录就是创建一个数据对象\n方法一\nMyModels.objects.create(属性1=值1,属性2=值2,\u0026hellip;)\n成功:返回创建好的实体对象\n失败:抛出异常\n方法二\n创建MyModel实例对象,并调用save()进行保存\nobj = MyModel(属性=值,属性=值) obj.属性 = 值 obj.save() ORM - 查询 数据库的查询需要使用管理器对象\n通过MyModel.objects管理器方法调用查询方法\n方法 说明 all() 查询全部记录,返回queryset查询对象 get() 查询符合条件的单一记录 filter() 查询符合条件的多条记录 exclude() 查询符合条件之外的记录 all()方法:\n​\t用法:MyModel.object是.all()\n​\t作用:查询MyModel试题中所有的数据,等同于select * from table\n​\t返回值:QuerySet()容器对象,内部存放MyModel实例\nfrom bookstore.models import Book books = Book.objects.all() for book in books: print(\u0026#34;书名\u0026#34;,book.title,\u0026#39;出版社\u0026#39;,book.pub) ​\t可以在模型类中定义__ str _方法,自定义QuerrySet中的输出格式\ndef __str__(self): return \u0026#39;%s_%s_%s_%s\u0026#39;%(self.title,self.price,self.pub,self.market_price) values(\u0026lsquo;列1\u0026rsquo;,\u0026lsquo;列2\u0026rsquo;\u0026hellip;):\n​\t用法:MyModel.objects.values(\u0026hellip;)\n​\t作用:查询部分列的数据并返回,等同于select 列1 ,列2 from xxx\n​\t返回值:QuerySet,返回查询结果容器,容器内存字典,每个字典代表一条数据\nvalues_list(\u0026lsquo;列1\u0026rsquo;,\u0026lsquo;列2\u0026rsquo;\u0026hellip;):\n​\t用法:MyModel.objects.values_list(\u0026hellip;)\n​\t作用:返回元组形式的查询结果 ,等同于select 列1,列2 from xxx\n​\t返回值:QuerySet容器对象,内部存放\u0026rsquo;元组\u0026rsquo;\norder_by():\n​\t用法:MyModel.objects.order_by(\u0026rsquo;-列\u0026rsquo;,\u0026lsquo;列\u0026rsquo;)\n​\t作用:与all()方法不同,他会用sql语句的order by子句对查询结果进行根据某个字段选择性的进行排序\n​\t返回值:QuerySet,返回查询结果容器,容器内存字典,每个字典代表一条数据\n​\t说明:默认是按照升序排序,降序排序需要在列前增加\u0026rsquo;-\u0026lsquo;表示\nfilter(条件):\n​\t用法:MyModel.objects.filter(属性1 = 值1,属性2 = 值2 )\n​\t作用:返回包含此条件的全部数据集\n​\t返回值:QuerySet容器对象,内部存放MyModel实例\nexclude(条件):\n​\t用法:MyModel.objects.exclude()\n​\t作用:返回不包含此条件的全部数据集\nget(条件):\n​\t用法:MyModel.objects.get(条件)\n​\t作用:返回满足条件的唯一一条数据\n​\t说明:该方法只能返回一条数据,查询结果多余一条数据则抛出出,Model/MultipleObjectsReturned异常,如果查询没有数据则抛出异常Model.DoesNotExist异常\n非等值条件的查询:\n​\t查询谓词\n​\t定义:做更灵活的条件查询时需要使用查询谓词\n​\t说明:每一个查询谓词是一个独立的查询功能\n​\t_exact:等值匹配\nAuthor.objects.filter(id_exact=1) # select * from author where id = 1 ​\t_contains:包含指定值\n​\t_startswith:以XXX开始\n​\t_endswith:以xxx结束\n​\t_gt:大于指定值\n​\t_gte:大于等于\n​\t_lt:小于\n​\t_lte:小于等于\n​\t_in:查找数据是否在指定范围内\n​\t_range:查找数据是否在指定的区间范围内\n聚合查询和原生数据库操作 聚合查询 定义:聚合查询是指对一个数据表中的一个字段进行部分或全部进行统计查询,查bookstore数据表中的全部书的平均价格,查询所有书的总个数等,都要使用聚合查询\n分类:\n整表聚合\n将全部数据进行集中统计查询\n聚合函数[需导入]:\n导入方法: from django.对比.models import * 聚合函数: Sum,Avg,Count,Max,Min 语法:\nMyModels.objects.aggregate(结果变量名=聚合函数(\u0026#39;列\u0026#39;)) -返回结果:结果变量名和值组成的字典 分组聚合\n分组聚合是指通过计算查询结果中每一个对象所关联的对象集合,从而得出总计值(也可以是平均值或总和),即为查询集的每一项生成聚合\n语法:\nQuerySet.annotate(结果变量名 = 聚合函数(\u0026lsquo;列\u0026rsquo;))\n返回值:\nQuerySet\n通过先用查询结果MyModel.objects.values查找查询要分组聚合的列\nMyModel.objects.values(\u0026lsquo;列1\u0026rsquo;,\u0026lsquo;列2\u0026rsquo;)\n通过返回结果的QuerySet.annotate方法分组聚合的到分组结果\nQuerySet.annotate(名=聚合函数(\u0026lsquo;列\u0026rsquo;))\n原生数据库操作 Django也可以支持 直接用sql语句的方式通信数据库\n查询:使用MyModel.objects.raw()进行 数据库查询操作\n语法:MyModel.objects.raw(sql语句,拼接参数)\n返回值:RawQuerySet集合对象[只支持基础操作,比如循环]\nbooks = models.Book.objects.raw(\u0026#39;select * from bookstore_book\u0026#39;) for book in books: print(book) 使用原生语句时小心sql注入\n定义:用户通过数据上传,将恶意的sql语句提交给服务器,从而达到攻击效果\norm多表查询 多表查询教程\nORM - 删除 单个数据删除\n查找查询结果对应的一个数据对象\n调用这个数据对象的delete()方法实现删除\ntry : auth = Author.objects.get(id=1) auth.delete() except: print(删除失败) 批量删除\n查找查询结果集中满足条件的全部QuerySet查询集合对象\n调用查询结合对象的delete()方法实现删除\nauths = Author.objects.filter(age_gt=65) auth.delete() 伪删除\n通常不会轻易在业务里把数据真正删掉，取而代之的是做伪删除，即在表中添加一个布尔型字段(is_active)，默认是True；执行删除时，将欲删除数据的is_active字段置为False 注意：用伪删除时，确保显示数据的地方均加了is_active=true的过滤查询 F对象和Q对象 F对象 一个F对象代表数据库中某条记录的字段的信息\n作用:\n通常是对数据库中的字段值再不获取的情况下进行操作\n用于类属性(字段)之间的比较\n语法\nfrom django.db.models import F F(\u0026#39;列名\u0026#39;) 示例1:\nBook.objects.all().update(market_price=F(\u0026#39;market_price\u0026#39;)+10) 示例2:对数据库两个字段的值进行比较\nfrom django.models import F from bookstore.models import Book books = Book,objects.filter(market_price__gt=F(\u0026#39;price\u0026#39;)) Q对象 当在获取查询结果集,使用复杂的逻辑或|,逻辑非~和\u0026amp;(and)操作时可以借助Q对象进行操作\nQ对象在数据包django.对比.models中,需先导入\nBook.objects.filter(Q(price__lt=20|Q(pub=\u0026#39;清华大学出版社\u0026#39;)) Django shell 在django提供了一个交互式的操作项目交django shell ,能够在交互模式用项目工程的代码执行相应的操作\n利用django shell 可以代替编写view的代码进行直接操作\n**tips:**项目代码发生变化时,重新进入Django shell\n启动方式:\npython3 manage.py shell 使用方法:\n![iShot2022-01-07 14.34.55](/Users/cobb/Documents/屏幕截图/iShot2022-01-07 14.34.55.png)\n![iShot2022-01-07 14.41.20](/Users/cobb/Documents/屏幕截图/iShot2022-01-07 14.41.20.png)\nadmin管理后台 创建后台管理账号 - 该账号为管理后台最高权限账号 python3 manage.py createsuperuser 注册自定义类型类 若要自己定义的模型类也能在admin后台管理界面显示和管理\n需要将自己的类注册到后台管理界面\n注册步骤:\n在应用app中的admin.py中导入注册要管理的模型models类,如:\nfrom .models import Book 调用admin.site.register方法进行注册,如:\nadmin.site.register(自定义模型类) 模型管理器类 作用:为后台界面添加便于操作的新功能\n说明:后台管理器类须继承自django.contrib.admin里的ModelAdmin类\n使用方法:\n在\u0026lt;应用app\u0026gt;/admin.py里定义模型管理器类\nclass XXXXManager(admin.Modeladmin): .... 绑定注册模型管理器和模型类\nfrom django.contrib import admin from .models import * admin.site.register(YYYY,XXXXManager) #绑定 YYYY模型类与管理器类 XXXXManager class BookManager(admin.ModelAdmin): #列表显示哪些字段的列 list_display = [\u0026#39;id\u0026#39;,\u0026#39;title\u0026#39;,\u0026#39;pub\u0026#39;,\u0026#39;price\u0026#39;] #控制哪些字段可以链接到修改页 list_display_links = [\u0026#39;title\u0026#39;] #添加过滤器 list_filter = [\u0026#39;title\u0026#39;] #添加搜索框[模糊查询] search_fields = [\u0026#39;title\u0026#39;] #添加可在列表页编辑的字段 list_editable = [\u0026#39;price\u0026#39;] admin.site.register(Book,BookManager) 关系映射 一对一 创建 语法:OneToOneField(类名,on_delete=xxx)\nclass A(model.Model): ... class B(model.Model): 属性 = models.OneToOneField(A,on_delete = xxx) 特殊字段选项(必须)\non_delete : 级联删除\nmoedls.CASCADE 级联删除.Django模拟sql约束ON DELETE CASCADE的行为,并删除包含ForeignKey的对象 models.PROTECT抛出ProtectedError以阻止被引用对象的删除,等同于mysql默认的RESTRICT SET_NULL设置ForeignKey null,需指定null = True SET_DEFAULT 将ForeignKey设置为其默认值,必须设置ForeignKey的默认值 示例:\nfrom django.db import models class Author(models.Model): name = models.CharField(\u0026#39;作家\u0026#39;,max_length=50) class wife(models.Model): name = models.CharField(\u0026#39;妻子\u0026#39;,max_length=50) #增加一对一属性 author = models.OneToOneField(Author,on_delete=models.CASCADE) 创建数据 无外键的模型列[Author]:\nauthor1 = Author.objects.create(name=\u0026lsquo;王老师\u0026rsquo;)\n有外键的模型类 [wife]\nwife1=wife. objects createname 王夫人，author= Author1）#关联王老师 obj wife1=wife. objects. create name-\u0026lsquo;王夫人，author id=1）#关联王老师对应主键值\n查询数据 正向查询:直接通过外键属性查询,称为正向查询\n#通过wife 找到author from .models import wife wife = wife.objects.get(name = \u0026#39;王夫人\u0026#39;) print(wife.name,\u0026#39;的老公是\u0026#39;,wife.author.name) 反向查询:没有外键属性的一方,可以调用反向属性查询到关联的另一方\n一对多 创建 语法:当一个A类对象可以关联多个B对象时\nclass A(models.Model): ... class B(models.Model): 属性 = models.ForeignKey(\u0026#34;一\u0026#34;的模型类,on_delete=xx) 创建数据 先创建一，再创建\nfrom .models import * pub1 = Publisher.objects.create(name = \u0026#39;清华大学出版社\u0026#39;) Book.objects.create(title = \u0026#39;c++\u0026#39;,publisher = pub1) Book.objects.create(title = \u0026#39;java\u0026#39;,publisher_id = 1) 查询数据 正向查询 [通过Book 查询 Publisher]\n通过 publisher 属性查询即可 book.publisher abook = Book.objects.get(id= 1) print(abook.title,\u0026#39;出版社是:\u0026#39;,abook.publisher.name ) 反向查询 [通过Publisher 查询 对应的所有的Book]\n需要用到反向属性\n#通过出版社查询对应的书 pub1 Pub lisher. objects. get（name=清华大学出版社） books= pub. book set.a1 #通过 book set 获取 pub1 对应的多个 Book 数据对象 # books = Book. objects. filter（publisher=pub1）#也可以采用此方式获取 prInt（\u0026#34;清华大学出版社的书有：\u0026#34;） for book in books print(book title) 多对多 语法:在关联的两个类中的任意一个类中,增加\n属性 = models.ManyToManyField(MyModel) 创建 示例:\n一个作者可以出版多个书籍\n一本书可以同时被多个作者同时编写\nclass Author (models.Model): ... class Book(models.Model): ... author = models.ManyToManyField(Author) 创建数据 方案一:先创建author 再关联 book\nauthor1 = Author.objects.create(name=\u0026#39;吕老师\u0026#39;) author2 = Author.objects.create(name=\u0026#39;王老师\u0026#39;) book11 = author1.book_set.create(title=\u0026#39;python\u0026#39;) author2.book_set.add(book11) 方案二:先创建book 再关联author\nbook = Book.objects.create(title= \u0026#39;python\u0026#39;) author3 = book.authors.create(name= \u0026#39;guoxiaonao\u0026#39;) book.authors.add(author1) 查询数据 正向查询 有多对多属性的对象 查 另一方\n通过Book查询对应的所有的Author\n此时多对多属性 等价于 objects\nbook.authors.all() # 获取book对应的所有的author 信息 book.authors.filter(age__gt=80) # 获取book对应的作者中年龄大于80的作者 反向查询\n通过Author查询对应的所有的Book\n利用反向属性book_set\nauthor.book_set.all() author.book_set.filter() cookies 和 session 会话 从打开浏览器访问一个网站，到关闭浏览器结束此次访问，称之为一次会话 HTTP 协议是无状态的，导致会话状态难以保持 Cookies 和 Session 就是为了保持会话状态而诞生的两个存储技术 ![image-20220111172759218](/Users/cobb/Library/Application Support/typora-user-images/image-20220111172759218.png)\nCookies \u0026mdash;长期存储 定义 cookies 是保存在刻画段浏览器上的存储空间\n特点 cookies 在浏览器上是以键-值对的形式进行存储的，键和值都是以 ASCII 字符串的形存储（不能是中文字符串） 存储的数据带有生命周期 cookies 中的数据是按域存储隔离的，不同的域之间无法访问 cookies 的内部的数据会在每次访问此网时都会携带到服务器端，如果 cookies 过大会降低响应速度 Cookies的使用 存储 HttpResponse. set_cookie(key, value=\u0026#39;\u0026#39; , max_age=None, expires=None) -key cookie 的名字 -value： cookie 的值 -max_ age： cookie 存活时间，秒为单位 -expIres：具体过期时间 -当不指定 max age 和 expires 时关闭浏览器时此数据失效 删除 或 获取 删除 Cookies\nHttpResponse. delete_cookie(key)\n删除指定的 key 的 Cookie。如果 key 不存在则什么也不发生\n获取 Cookies\n通过 request. COOKIES 绑定的字典（dict）获取客户端的 COOKIES 数据\nvalue = request. COOKIES.get (\u0026lsquo;cookies 名\u0026rsquo;，\u0026lsquo;默认值\u0026rsquo;） session \u0026mdash;短期存储 session是在服务器上开辟一段空间用于保留浏览器和服务器交互时的重要数据\n实现方式:\n使用session需要在浏览器客户端启动cookies,且在cookies中存储sessionid 每个客户端都可以在客户端都可以在服务器端有一个独立的session 注意:不同的请求者之间不会共享这个数据,与请求者一一对应 session 初始配置 settings.py中配置session\n向INSTALLED_APPS列表中添加\nINSTALLED_APPS = [ #启用 session应用 \u0026#39;django.contrib.session\u0026#39;, ] 向MIDDLEWARE列表中添加\nMIDDLAEWARE = [ # 启用 Session 中间件 \u0026#39;django.contrib.sessions.middleware.SessionMiddleware\u0026#39; ] session的使用 session对于对象是一个类似于字典的SessionStore类型的对象,可以用类似于字典的方式进行操作\nsession能够存储如字符串,整型,字典,列表等\n保存session的值到服务器\nrequest.session[\u0026lsquo;KEY\u0026rsquo;] = VALUE\n获取session的值\nvalue = request.session[\u0026lsquo;KEY\u0026rsquo;]\nvalue = request.session.get(\u0026lsquo;KEY\u0026rsquo;,默认值)\n删除session\ndel request.session[\u0026lsquo;KEY\u0026rsquo;]\n![image-20220111192926827](/Users/cobb/Library/Application Support/typora-user-images/image-20220111192926827.png)\n![image-20220111193019999](/Users/cobb/Library/Application Support/typora-user-images/image-20220111193019999.png)\ndjang实现前后端数据交互 Django 从后台往前台传递数据时有多种方法可以实现。\n最简单的后台是这样的：\nfrom django.shortcuts import render def main_page(request): return render(request, \u0026#39;index.html\u0026#39;) 这个就是返回index.html的内容，但是如果要带一些数据一起传给前台的话，该怎么办呢？\n一 view -\u0026gt; HTML 使用Django模版 这里是这样：后台传递一些数据给html，直接渲染在网页上，不会有什么复杂的数据处理（如果前台要处理数据，那么就传数据给JS处理）\nDjango 代码：\nfrom django.shortcuts import render def main_page(request): data = [1,2,3,4] return render(request, \u0026#39;index.html\u0026#39;, {\u0026#39;data\u0026#39;: data}) html使用 {{ }} 来获取数据\n\u0026lt;div\u0026gt;{{ data }}\u0026lt;/div\u0026gt; 可以对可迭代的数据进行迭代：\n{% for item in data%} \u0026lt;p\u0026gt;{{ item }}\u0026lt;/p\u0026gt; {% endfor %} 该方法可以传递各种数据类型，包括list，dict等等。 而且除了 {% for %} 以外还可以进行if判断，大小比较等等。具体的用法读者可以自行搜索。\n二 view-\u0026gt; JavaScript 如果数据不传给html用，要传给js用，那么按照上文的方式写会有错误。 需要注意两点：\nviews.py中返回的函数中的值要用 json.dumps() 处理 在网页上要加一个 safe 过滤器。 代码： views.py\n# -*- coding: utf-8 -*- import json from django.shortcuts import render def main_page(request): list = [\u0026#39;view\u0026#39;, \u0026#39;Json\u0026#39;, \u0026#39;JS\u0026#39;] return render(request, \u0026#39;index.html\u0026#39;, { \u0026#39;List\u0026#39;: json.dumps(list), }) JavaScript部分：\nvar List = {{ List|safe }}; 三 JavaScript Ajax 动态刷新页面 这个标题的意思是：网页前台使用Ajax发送请求，后台处理数据后返回数据给前台，前台不刷新网页动态加载数据\nDjango 代码：\ndef scene_update_view(request): if request.method == \u0026#34;POST\u0026#34;: name = request.POST.get(\u0026#39;name\u0026#39;) status = 0 result = \u0026#34;Error!\u0026#34; return HttpResponse(json.dumps({ \u0026#34;status\u0026#34;: status, \u0026#34;result\u0026#34;: result })) JS 代码：\nfunction getSceneId(scece_name, td) { var post_data = { \u0026#34;name\u0026#34;: scece_name, }; $.ajax({ url: {% url \u0026#39;scene_update_url\u0026#39; %}, type: \u0026#34;POST\u0026#34;, data: post_data, success: function (data) { data = JSON.parse(data); if (data[\u0026#34;status\u0026#34;] == 1) { setSceneTd(data[\u0026#34;result\u0026#34;], scece_name, td); } else { alert(data[\u0026#34;result\u0026#34;]); } } }); } JS 发送ajax请求，后台处理请求并返回status, result 在 success: 后面定义回调函数处理返回的数据，需要使用 JSON.parse(data)\n","permalink":"https://sirius00.github.io/posts/tech/django%E7%9A%84%E4%BD%BF%E7%94%A8/","summary":"安装django 安装django ：pip3 install django==2.2.12 检查安装的django版本：python -m django \u0026ndash;version 创建项目 django-amdin startproject mysite 启动服务 1、进入项目文件夹 2、python3 manage.py runserver 改变端口号 python manage.py runserver 端口号 项目结构 manage.py: 一个让你用各种方式管理 Django 项目的命令行工具 runserver：启动服务 startapp：创建应用","title":"Django的使用"},{"content":"","permalink":"https://sirius00.github.io/posts/tech/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/","summary":"","title":"数据结构"},{"content":"一、HTTP协议 1.GET和POST请求的区别 应用场景: GET请求是一个幂等的请求(在程序中如果相同条件下多次请求对资源的影响表现一致则称为幂等请求), 一般get请求用于对服务器资源不会产生影响的场景, 比如请求一个网页的资源. 而POST不是一个幂等的请求, 一般用于对服务器资源会产生影响的情景, 比如注册用户这一类的操作 是否缓存: 浏览器一般会对GET请求缓存, 但很少对post请求缓存 发送的报文格式: Get请求的报文中实体部分为空, POST请求的报文中实体部分一般为向服务器发送的数据 安全性: get请求可以将请求的参数放入url向服务器发送请求, 这样的做法相对于post来说不太安全, 因为请求的url会被保留在历史记录中 请求长度: 浏览器对于url长度的限制, 所以会影响get请求请求数据时的长度, 这个限制是浏览器规定的, 并不是RFC规定的 参数类型: post的参数传递支持更多的数据类型 2. POST和PUT请求的区别 put请求是向服务器端发送数据, 从而修改数据的内容, 但是不会增加数据的种类等, 也就是说无论进行多少次PUT操作, 其结果并没有不同. (可以理解为更新数据) post请求事向服务器发送数据, 该请求会改变数据的种类资源, 他会创建新的内容. (可以理解为创建数据) 3.常见的HTTP请求头和响应头 HTTP Request Header 常见的请求头:\nAccept: 浏览器能够处理的内容类型 Accept-Charset: 浏览器能够显示的字符集 Accept-Encodeing: 浏览器能够处理的压缩编码 Accept-Language: 浏览器当前设置的语言 Connection: 浏览器与服务器之间连接的类型 Cookie: 当前页面设置的任何cookie Host: 发出请求的页面所在域 Referer: 发出请求的页面的URL User-Agent: 浏览器的用户代理字符串 HTTP Responses Header 常见的响应头:\nDate: 表示消息发送的时间, 时间的描述格式由rfc822定义 server: 服务器名称 Connection: 浏览器与服务器之间连接的类型 Cache-Control: 控制HTTP缓存 content-type: 表示后面的文档属于什么MIME类型 常见的Content-type 属性值有以下几种: (1): application/x-www-form-urlencoded: 浏览器的原生form表单, 如果不设置enctype属性, 那么最终就会以application/x-www-form-urlencoded方式提交数据. 该种方式提交的数据放在body里面, 数据按照key1=val1\u0026amp;key2=val2的方式进行编码, key和val都进行URL转码 (2)multipart/form-data: 该种方式也是一个常见的POST提交方式, 通常表单上传文件时使用这种方式 (3)application/json: 服务器消息主体是序列化后的JSON字符串 (4)text/xml: 该种方式主要用来提交XML格式的数据\n4. 常见HTTP状态码 100: 部分请求已经被服务器接收，且仍未被拒绝，客户端应当继续发送请求的剩余部分，post请求时会发2次请求，第一次只把头部发送给服务端确认，服务器返回100时才继续把内容发送给服务端，这样做的目的时万一因为某些原因服务器需要拒绝请求（如没权限），白白发送那么多数据。 101：切换协议，如websocket连接时会出现这种情况。 200：正常 204：服务器成功处理了请求，但无内容返回； 301：永久移动，比如 baidu.com跳转到 www.baidu.com 302：临时移动； 304: 内容未修改，客户端可以继续使用本地缓存； 400：请求数据不正确，服务器不理解请求的语法； 401：未授权，未登录； 403：服务器拒绝请求； 404：请求的地址不存在； 405：请求的方法不对，比如该POST的地方用了GET； 500：服务器内部错误； 504：网关超时，比如nginx代理经常碰到这种错误； 5.常见的HTTP请求方法 GET: 向服务器获取数据 POST: 将实体提交到指定的资源, 通常会造成服务器资源的修改 PUT: 上传文件, 更新数据 DELETE: 删除服务上的对象 HEAD: 获取报文首部, 与GET相比, 不返回报文主体部分 OPTIONS: 询问支持的请求方法, 用来跨域请求 CONNECT: 要求在于代理服务器通信时建立隧道, 使用隧道进行TCP通信 TRACE: 回显服务器收到的请求, 主要用于测试或诊断 6. OPTIOS请求方法及应用场景 OPTIONS方法是用于请求获得由 Request-URI 标识的资源在请求/响应的通信过程中可以使用的功能选项, 通过这个方法, 客户端可以在采取具体资源请求之前, 决定对资源采取和中必要措施, 或者了解服务起的性能. 该请求方法的响应不能缓存.\nOPTIONS 请求方法的主要用途:\n获取服务器支持的所有HTTP请求方法 用来检查访问权限, 例如: 在进行CORS卡与资源共享时, 对于复杂请求, 就是使用OPTIONS方法发送嗅探请求, 以判断是否有对指定资源的访问权限 6.HTTP和HTTPS协议的区别 HTTPS协议需要CA证书, 费用较高; 而HTTP协议不需要 HTTP协议是超文本传输协议，信息是明文传输的，HTTPS则是具有安全性的SSL加密传输协议； 使用不同的连接方式，端口也不同，HTTP协议端口是80，HTTPS协议端口是443； HTTP协议连接很简单，是无状态的；HTTPS协议是有SSL和HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP更加安全。 7.在浏览器搜索的处理流程 解析URL: 首先对URL进行解析, 分析所需要使用的传输协议和请求的资源的路径. 如果输入的URL中的协议或者主机名不合法, 将会把地址中输入的内容传递给搜索引擎. 如果没有问题, 浏览器会检查URL中是否出现了非法字符, 如果存在非法字符, 则对非法字符进行转义后再进行下一过程 缓存判断: 浏览器会判断所请求的资源是否存在缓存里, 如果请求的资源在缓存里并且没有失效, 那么直接使用, 否则像服务器发起新的请求 DNS解析: 下一步首先需要获取的是输入的URL中的域名 ","permalink":"https://sirius00.github.io/posts/tech/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/","summary":"一、HTTP协议 1.GET和POST请求的区别 应用场景: GET请求是一个幂等的请求(在程序中如果相同条件下多次请求对资源的影响表现一致则称为幂等请求), 一般get请求用于对服务器资源不会产生影响的场景, 比如请求一个网页的资源. 而POST不是一个幂等的请求, 一般用于对服务器资源会产","title":"计算机网络"},{"content":"canvas画布宽度和高度 canvas标签只有两个标签属性: width和height\n当没有设置宽度和高度的时候, canvas会初始化为宽300px, 高150px画布\n使用html属性设置width, height 时,只影响画布本身,不影响画布内容\n使用css样式指定canvas的width, height时, 不但影响画布本身的宽高, 还会使画布内容等比例缩放\n\u0026lt;!-- 不要通过样式指定宽高 --\u0026gt; \u0026lt;canvas id=\u0026#34;canvas\u0026#34; width=\u0026#34;400\u0026#34; height=\u0026#34;200\u0026#34; style=\u0026#34;border: 1px solid\u0026#34;\u0026gt;\u0026lt;/canvas\u0026gt; canvas画笔 const canvas = document.getElementById(\u0026#39;canvas\u0026#39;) // 检查浏览器是否支持canvas if (canvas.getContext) { // canvas相关的操作基本都在ctx上面进行 const ctx = canvas.getContext(\u0026#39;2d\u0026#39;) } canvas绘制矩形 fillRect(填充矩形)\nstrokeRect(边框矩形)\nctx.fillRect(x, y, width, height)\nctx.strokeRect(x, y, width, height)\n两者参数:\nx:x轴偏移量 y: y轴偏移量 width: 矩形宽度 height: 矩形高度 strokeRect边框矩形渲染问题 canvas 在渲染矩形边框时，边框宽度是平均分在偏移位置两侧的。\n// 边框会渲染在 49.5-50.5 之间，浏览器是不会让一个像素只显示一半的，只会全部显示。相当于边框会渲染在 49-51 之间，也就是 2px ctx.strokeRect(50, 50, 100, 100) // 将偏移量多移动 0.5，边框会渲染在 200-201 和 50-51 之间，也就是1px ctx.strokeRect(200.5, 50.5, 100, 100) canvas清除区域 ctx.clearRect(x, y, width, height)：可以清除 canvas 画布上指定的区域，让清除部分完全透明\nctx.fillRect(50, 50, 100, 100) // 以 (100, 100) 为偏移量，清除一个 50 * 50 的区域 ctx.clearRect(100, 100, 50, 50) canvas样式和颜色 ctx.fillStyle：设置图像的填充颜色。（默认黑色）\nctx.strokeStyle：设置图像轮廓的颜色。（默认黑色）\nctx.lineWidth：设置当前绘线的粗细，属性值必须为正数（默认值 1，0、负数、Infinity 和 NaN 会被忽略）。\nctx.lineJoin：设定线条与线条间结合的样式。（默认miter）\nround：圆角。\nbevel：斜角。\nmiter：直角。\n// 填充样式红色 ctx.fillStyle = \u0026#39;red\u0026#39; // 边框样式蓝色 ctx.strokeStyle = \u0026#39;blue\u0026#39; // 绘线粗细 10px ctx.lineWidth = 10 // 绘线交接呈现圆角 ctx.lineJoin = \u0026#39;round\u0026#39; ctx.fillRect(50, 50, 100, 100) ctx.strokeRect(200, 50, 100, 100) canvas路径 路径绘制矩形 ctx.stroke()：通过线条来绘制图像轮廓，不会自动调用 closePath()。\nctx.fill()：通过填充路径的内容区域生成实心的图像，自动调用closePath()。\nctx.rect(x, y, width, height)：绘制一个偏移量 (x, y)，宽 width，高 height 的矩形。\n当该方法执行的时候，moveTo() 方法自动设置起点坐标为 (x, y)。\n该方法执行完毕的时候，画布上不会呈现图像，相当于只是形成了路径列表，要调用 fill() 或 stroke() 方法才会呈现在画布中\n// 绘制路径不显示 ctx.rect(50, 50, 100, 100) // 填充显示 ctx.fill() ctx.rect(200, 50, 100, 100) // 路径连接显示 ctx.stroke() 重置路径和闭合路径 ctx.beginPath()：新建一条路径，生成之后，图像绘制命令被指向到路径上准备生成路径。\n本质上，路径是由多个子路径构成，这些子路径都是在一个路径列表中，每次调用 beginPath，路径列表都会清空重置。 通常我们在绘制图像之前，都会调用该方法 ctx.moveTo(x, y)：将画笔移动到指定的坐标轴上。（设置起点）\nctx.lineTo(x, y)：绘制一条从当前位置到指定坐标轴位置的直线。\nctx.closePath()：闭合路径，图像绘制命令又重新指向到上下文中。\n使用 fill() 绘制图像或图像路径已经闭合不需要使用此方法。 通常使用 stroke() 绘制图像的时候才使用此方法。 // 自动填充路径 ctx.beginPath() ctx.moveTo(50, 50) ctx.lineTo(100, 50) ctx.lineTo(100, 100) ctx.fill() // 路径不会自动闭合 ctx.beginPath() ctx.moveTo(150, 50) ctx.lineTo(200, 50) ctx.lineTo(200, 100) ctx.stroke() // 手动闭合路径 ctx.beginPath() ctx.moveTo(250, 50) ctx.lineTo(300, 50) ctx.lineTo(300, 100) ctx.closePath() ctx.stroke() 路径绘制样式 ctx.lineCap：绘制每一条线段末端的样式属性。\nbutt：线段末端以方形结束。（默认值） round：线段末端以圆形结束。 square：线段末端以方形结束，但是增加了一个宽度和线段相同，高度是线段宽度一半的矩形区域。 // 绘线末端圆形显示 ctx.lineCap = \u0026#39;round\u0026#39; ctx.lineWidth = 10 ctx.moveTo(50, 50) ctx.lineTo(100, 50) ctx.lineTo(100, 100) ctx.stroke() canvas状态 ctx.save()：将当前状态放入栈中，保持 canvas 全部状态的方法。\n保存到栈中的绘制状态由下面部分组成。\n当前的变换矩阵。\n当前的剪切区域。\n当前的虚线列表。\n绘制图像的样式（strokeStyle / fillStyle / lineWidth / lineJoin / lineCap …）。\nctx.restore()：通过在绘图状态栈中弹出顶端的状态，将 canvas 恢复到最近的保存状态的方法，如果没有保存状态，此方法不做任何改变。\n通常我们在绘制图像进行的操作，都会放在 save() 和 restore() 方法之间，避免当前绘制图像设置的状态，影响到后续图像的绘制效果。\n// 画布默认状态放入栈中 ctx.save() // 当前填充样式设置为红色 ctx.fillStyle = \u0026#39;red\u0026#39; // 绘制矩形，显示效果为红色 ctx.fillRect(50, 50, 100, 100) // 弹出栈中顶端状态，这个时候红色的填充样式会被弹出的状态覆盖，变为黑色 ctx.restore() // 绘制矩形，显示效果为黑色 ctx.fillRect(200, 50, 100, 100) canvas圆形/圆弧 ctx.arc(x, y, radius, startAngle, endAngle, anticlockwise)：画一个以(x, y)坐标为圆心，radius 为半径的圆弧或圆，从 startAngle 开始，到 endAngle 结束。\n参数如下：\nx：圆心在画布 x 轴上的偏移量。 y：圆心在画布 y 轴上的偏移量。 radius：绘制圆的半径。 startAngle：圆弧的起始点，x 轴方向开始计算，单位以弧度表示。 endAngle：圆弧的终点，单位以弧度表示。 anticlockwise：布尔值。true 表示逆时针，false 表示顺时针。（默认值） ctx.arcTo(x1, y1, x2, y2, radius)：根据设置的两个控制点和半径画一段圆弧。\n必须存在一个开始坐标点 ctx.moveTo(x, y)，三点才能构成圆弧，半径为 radius 的圆向夹角里面填充。 绘制的圆弧一定经过起点，但不一定经过 (x1, y1) 和 (x2, y2)，这两个坐标只是用来控制方向的。 canvas贝塞尔曲线 二次贝塞尔 ctx.quadraticCurveTo(cpx, cpy, x, y)：绘制二次贝塞尔曲线。\n参数：\ncpx：控制点的 x 轴坐标。\ncpy：控制点的 y 轴坐标。\nx：终点的 x 轴坐标。\ny：终点的 y 轴坐标。\n注意:\n必须要设置起点 moveTo(x, y)。 二次贝塞尔曲线一定经过起点和终点。 // 将3个点连接起来 ctx.beginPath() ctx.moveTo(20, 20) ctx.lineTo(200, 0) ctx.lineTo(100, 100) ctx.stroke() // 观察二次贝塞尔曲线在3点之间的位置 ctx.beginPath() ctx.moveTo(20, 20) ctx.quadraticCurveTo(200, 0, 100, 100, 20) ctx.stroke() 三次贝塞尔 ctx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y)：绘制三次贝塞尔曲线。\n参数只是在二次贝塞尔的基础上多增加了一个控制点 (cp2x, cp2y)。\n同样要设置起点 moveTo(x, y)，也一定经过起点和终点。\n// 将4个点连接起来 ctx.beginPath() ctx.moveTo(20, 20) ctx.lineTo(200, 0) ctx.lineTo(100, 100) ctx.lineTo(200, 100) ctx.stroke() // 观察三次贝塞尔曲线在4点之间的位置 ctx.beginPath() ctx.moveTo(20, 20) ctx.bezierCurveTo(200, 0, 100, 100, 200, 100, 20) ctx.stroke() canvas变换 平移变换 ctx.translate(x, y)：对当前 canvas 画布进行平移变换。\nx：水平方向的移动距离。\ny：垂直方向的移动距离。\n注意：在 canvas 中 translate 是累加的。\n// x 轴和 y 轴都平移 50px ctx.translate(50, 50) ctx.fillRect(0, 0, 100, 100) 旋转变换 ctx.rotate(angle)：将当前 canvas 画布对照原点顺时针旋转。\nangle：顺时针旋转的弧度(degree * Math.PI / 180), 旋转的中心始终是 canvas 的原点 (0, 0)，x 轴顺时针旋转，如果要改变中心点，我们可以通过 translate() 方法移动 canvas\n注意：在 canvas 中 rotate 是累加的\nctx.translate(50, 50) // 顺时针旋转 45 度 ctx.rotate(45 * Math.PI / 180) ctx.fillRect(0, 0, 100, 100) 伸缩变换 ctx.scale(x, y)：将当前 canvas 画布的 x 轴和 y 轴进行伸缩变换。\n参数：\nx：水平方向的缩放因子。 y：垂直方向的缩放因子。 注意:\n在 canvas 中 scale 是累加的。 缩放因子为 1 时大小不变，值为负数按照 x 轴或 y 轴进行翻转（翻转上下文） 默认的，在 canvas 中一个单位实际上就是一个像素。例如，如果我们将 0.5 作为缩放因子，最终的单位会变成 0.5 像素，并且形状的尺寸会变成原来的一半。相似的方式，我们将 2.0 作为缩放因子，将会增大单位尺寸变成两个像素。形状的尺寸将会变成原来的两倍。\nctx.translate(50, 50) // x 轴放大 2 倍，y 轴不变 ctx.scale(2, 1) ctx.fillRect(0, 0, 100, 100) 文字翻转 // x 轴放大 2 倍，并翻转，y 轴不变 ctx.scale(-2, 1) ctx.font = \u0026#39;48px serif\u0026#39; ctx.fillText(\u0026#39;canvas\u0026#39;, -200, 100) canvas背景 图片背景 ctx.drawImage(img, sx, sy, swidth, sheight, x, y, width, height)：在画布上绘制图片。\n参数：\nimg：图像源对象（规定使用的图像、画布或视频等）。 sx：可选，开始剪切的x坐标位置。 sy：可选，开始剪切的y坐标位置。 swidth：可选，被剪切图像的宽度。 sheight：可选，被剪切图像的高度。 x：在画布上放置图像的x坐标位置。 y：在画布上放置图像的y坐标位置。 width：可选，要使用的图像的宽度（伸展或缩小图像）。 height：可选，要使用的图像的高度（伸展或缩小图像）。 注意: 必须要等图片加载完才能操作，参数必须如下 3 种方式(3, 5, 9)\n\u0026lt;img id=\u0026#34;img\u0026#34; src=\u0026#34;./img/react.png\u0026#34;\u0026gt; \u0026lt;canvas id=\u0026#34;canvas\u0026#34; width=\u0026#34;400\u0026#34; height=\u0026#34;200\u0026#34; style=\u0026#34;border: 1px solid\u0026#34;\u0026gt;\u0026lt;/canvas\u0026gt; ctx.drawImage(img, x, y)：在画布上定位图像。\nconst img = new Image() img.src = \u0026#39;./img/react.png\u0026#39; img.onload = () =\u0026gt; { // 将图片绘制到画布上 ctx.drawImage(img, 0, 0) } ctx.drawImage(img, x, y, width, height)：在画布上定位图像，并规定图像的宽度和高度。\nctx.drawImage(img, 0, 0, 100, 100) ctx.drawImage(img, sx, sy, swidth, sheight, x, y, width, height)：剪切图像，并在画布上定位被剪切的部分。\nctx.drawImage(img, 0, 0, 100, 100, 0, 0, 100, 100) 设置背景 ctx.createPattern(image, repetition)：创建一个用于图像绘制使用的样式。\n参数：\nimage：图像源对象（规定使用的图像、画布或视频等）。 repetition：重复图像的方式，值只能是 repeat | repeat-x | repeat-y | no-repeat。 repetition 如果为空字符串 (’’) 或 null (但不是 undefined )，repetition将被当作 repeat\n// 创建背景样式 const pat = ctx.createPattern(img, \u0026#39;repeat\u0026#39;) ctx.fillStyle = pat ctx.fillRect(0, 0, 300, 100) canvas渐变 线性渐变 ctx.createLinearGradient(x1, y1, x2, y2)：从 (x1, y1) 到 (x2, y2) 进行渐变。\n该方法返回一个 CanvasGradient 对象。\n使用 CanvasGradient 身上的 addColorStop(position, color) 设置渐变颜色。\n参数：\nposition：介于 0-1 之间的值，表示渐变中开始与结束之间的位置。 color：在position位置显示的css颜色值 // 从 (0, 0) 坐标点到 (300, 0) 坐标点进行渐变 const line = ctx.createLinearGradient(0, 0, 300, 0) // 渐变顺序 红 --\u0026gt; 蓝 --\u0026gt; 绿 line.addColorStop(0, \u0026#39;red\u0026#39;) line.addColorStop(.5, \u0026#39;blue\u0026#39;) line.addColorStop(1, \u0026#39;green\u0026#39;) // 图像填充颜色设置为渐变色 ctx.fillStyle = line ctx.fillRect(0, 0, 300, 100) 径向渐变 ctx.createRadialGradient(x1, y1, r1, x2, y2, r2)：从 (x1, y1) 为圆心，半径为 r1 的圆，向 (x2, y2) 为圆心，半径为 r2 的圆进行径向渐变。\n使用方法跟上述的 createLinearGradient 一样。\n// 以 (200, 100) 为圆心 50 为半径，向 100 为半径的圆渐变 const grad = ctx.createRadialGradient(200, 100, 50, 200, 100, 100) // 渐变顺序 红 --\u0026gt; 蓝 --\u0026gt; 绿 grad.addColorStop(0, \u0026#39;red\u0026#39;) grad.addColorStop(.5, \u0026#39;blue\u0026#39;) grad.addColorStop(1, \u0026#39;green\u0026#39;) // 图像填充颜色设置为渐变色 ctx.fillStyle = grad ctx.fillRect(0, 0, 400, 200) canvas文本相关 文本相对于画布的偏移量，都是参照文本的基线进行偏移的。\n渲染文本 canvas 中提供了两种方法渲染文本，如下：\nctx.fillText(text, x, y, [maxWidth])：在 (x, y) 填充指定的文本 (text)。\nctx.strokeText(text, x, y, [maxWidth])：在 (x, y) 绘制文本边框 (text)。\n参数：\ntext：文本内容。 x, y：偏移量。 maxWidth：字体绘制的最大宽度，绘制字体宽度超出最大宽度会水平自适应 // 边框文本 ctx.strokeText(\u0026#39;天天好心情\u0026#39;, 50, 50) // 填充文本 ctx.fillText(\u0026#39;天天好心情\u0026#39;, 50, 100) // 填充文本现在宽度 ctx.fillText(\u0026#39;天天好心情\u0026#39;, 50, 150, 30) 文本样式 设置字体 ctx.font：font 属性指定时，必须要有大小和字体，缺一不可。\n默认字体 10px sans-serif。\n文本对齐方式 ctx.textAlign：设置文本的对齐方式，值如下：\nstart：文本对齐界线开始的地方。（默认值） end：文本对齐界线结束的地方。 left：文本左对齐。 right：文本右对齐。 center：文本居中对齐。 这里的 textAlign = ‘center’ 比较特殊。textAlign 的值为 center 时候文本的居中是基于你在 (fillText / strokeText) 的时候所给的x的值，也就是说文本一半在 x 的左边，一半在 x 的右边（可以理解为计算 x 的位置时从默认文字的左端，改为文字的中心，因此你只需要考虑 x 的位置即可）。所以，如果你想让文本在整个 canvas 居中，就需要将 (fillText / strokeText) 的x值设置成 canvas 的宽度的一半。\nctx.font = \u0026#39;30px sans-serif\u0026#39; // 文本居中对齐 ctx.textAlign = \u0026#39;center\u0026#39; ctx.strokeText(\u0026#39;天天好心情\u0026#39;, 50, 50) 文本基线对齐方式 文本相对于画布的偏移量，都是参照文本的基线进行偏移的，设置基线在文本中的位置，可以调整文本在 canvas 画布中的位置。\nctx.textBaseline：描绘绘制文本时，当前文本基线的属性，值如下：\nalphabetic：文本基线是标准的字母基线。（默认值）\ntop：文本基线在文本块的顶部。\nmiddle: 文本基线在文本块的中间。\nbottom：文本基线在文本块的底部。\nhanging：文本基线是悬挂基线。\nideographic：文本基线是表意字基线。\n如果字符本身超出了 alphabetic 基线，那么 ideographic 基线位置在字符本身的底部\nctx.font = \u0026#39;30px sans-serif\u0026#39; ctx.textAlign = \u0026#39;center\u0026#39; // 基线设置在文本的顶部 ctx.textBaseline = \u0026#39;top\u0026#39; ctx.strokeText(\u0026#39;天天好心情\u0026#39;, 50, 50) 文本在canvas中垂直居中显示 ctx.font = \u0026#39;30px sans-serif\u0026#39; // x 轴偏移画布一半，水平按文本中间对齐 ctx.textAlign = \u0026#39;center\u0026#39; // y 轴偏移画布一半，基线设置在文本的中心位置 ctx.textBaseline = \u0026#39;middle\u0026#39; ctx.fillText(\u0026#39;天天好心情\u0026#39;, canvas.width / 2, canvas.height / 2) 获取文本信息 ctx.measureText(text)：返回一个 TextMetrics 对象，包含关于文本尺寸的信息（一般都用来获取文本的宽度）。\n参数：\ntext：文本内容。 ctx.font = \u0026#39;100px serif\u0026#39; // 返回当前文本的相关信息 const textInfo = ctx.measureText(\u0026#39;天天好心情\u0026#39;) console.log(textInfo) canvas阴影 设置 canvas 图像或文字阴影需要如下属性：\nctx.shadowOffsetX：图像 x 轴延伸距离。（默认值 0） ctx.shadowOffsetY：图像 y 轴延伸距离。（默认值 0） ctx.shadowBlur：用来设定阴影的模糊程度，其数值并不跟像素数量挂钩，也不受变换矩阵的影响。（默认值 0） ctx.shadowColor：必须是标准的CSS颜色值，用于设定阴影颜色效果。（默认是全透明的黑色） // 图像阴影向左移动 10px ctx.shadowOffsetX = 10 // 图像阴影向下移动 10px ctx.shadowOffsetY = 10 // 模糊程度为 10 ctx.shadowBlur = 10 // 阴影颜色为红色 ctx.shadowColor = \u0026#39;red\u0026#39; ctx.fillRect(50, 50, 100, 100) canvas像素相关 获取区域内像素信息 ctx.getImageData(x, y, width, height)：返回一个 ImageData 对象，用来描述 canvas 区域隐含的像素数据，这个区域通过矩形表示，起始点是 (x, y)，宽为 width，高为 height。\nimageData 对象中存储着 canvas 对象真实的像素数据，它包含以下几个只读属性：\nwidth：图片的宽度，单位是像素。\nheight：图片的高度，单位是像素。\ndata：Uint8ClampedArray 类型的一维数组，包含着 RGBA 格式的整型数组，范围在 0-255 之间 (包括255)。按图像从左到右，从下到下记录像素的\nconst img = new Image() img.src = \u0026#39;./img/react.png\u0026#39; img.onload = () =\u0026gt; { ctx.drawImage(img, 0, 0, 100, 100) // 获取绘制图像区域内的相关信息 const imgData = ctx.getImageData(0, 0, 100, 100) console.log(imgData) } 图像的长和宽都是 100，所以一共有 10000 个像素点 (100 * 100)，因为一个像素点对应一个 RGBA 值，一个 RGBA 值由 4 个数值构成，所以 data 数组的长度为 40000。\n该数组每 4 个值构成一个像素点。\n对画布进行像素数据的写入 ctx.putImageData(imagedata, dx, dy)\nctx.putImageData(imagedata, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight)\n将数据从已有的 ImageData 对象绘制到位图的方法。 如果提供了一个绘制过的矩形，则只绘制该矩形的像素。此方法不受画布转换矩阵的影响\n参数:\nimagedata：包含像素值的数组对象。 dx：源图像数据在目标画布中的位置偏移量（x 轴方向的偏移量）。 dy：源图像数据在目标画布中的位置偏移量（y 轴方向的偏移量）。 dirtyX：可选，在源图像数据中，矩形区域左上角的位置。默认是整个图像数据的左上角（x 坐标）。 dirtyY：可选，在源图像数据中，矩形区域左上角的位置。默认是整个图像数据的左上角（y 坐标）。 dirtyWidth：可选，在源图像数据中，矩形区域的宽度。默认是图像数据的宽度。 dirtyHeight：可选，在源图像数据中，矩形区域的高度。默认是图像数据的高度。 const img = new Image() img.src = \u0026#39;./img/react.png\u0026#39; img.onload = () =\u0026gt; { ctx.drawImage(img, 0, 0, 100, 100) const imgData = ctx.getImageData(0, 0, 100, 100) // 将 ImageData 对象重新写入到画布中 ctx.putImageData(imgData, 200, 100, 0, 0, 50, 50) } 创建imageData对象 ctx.createImageData(width, height)\nctx.createImageData(imagedata)\n创建一个新的、空的、指定大小的imageData 对象，所有像素在新对象中都是透明的。（data 数组中的值都是 0）\n参数:\nwidth：imageData 新对象的宽度。 height：imageData 新对象的高度。 imagedata：从现有的 ImageData 对象中，复制一个和其宽度和高度相同的对象。图像自身不允许被复制。（data 数组中的值都是 0） const img = new Image() img.src = \u0026#39;./img/react.png\u0026#39; img.onload = () =\u0026gt; { ctx.drawImage(img, 0, 0, 100, 100) const imgData = ctx.getImageData(0, 0, 100, 100) // 根据老的 ImageData 对象，创建一个新的 ImageData 对象 const imgDataByData = ctx.createImageData(imgData) console.log(\u0026#39;imgDta创建\u0026#39;, imgDataByData) // 根据指定的宽高，创建一个新的 ImageData 对象 const imgDataByRect = ctx.createImageData(10, 10) console.log(\u0026#39;宽高创建\u0026#39;, imgDataByRect) } 像素扩展 获取某个坐标的像素 通过 getImageData 方法我们可以获取到整个 canvas 画布的像素信息。已知坐标 (x, y)，通过 (y * canvas.width + x) 可以获取这是第几个像素。因为一个像素包含 RGBA 4 个数值，所以最后获取到的像素为 (y * canvas.width + x) * 4，加上紧跟的后 3 位所对应的数值构成的 RGBA 值\n// 获取 imageData 中某个坐标的像素 function getPixelInfo(imageData, x, y) { const { width, data } = imageData const pixel = [] const index = (y * width + x) * 4 pixel[0] = data[index] pixel[1] = data[index + 1] pixel[2] = data[index + 2] pixel[3] = data[index + 3] return pixel } 测试 ctx.fillStyle = \u0026#39;red\u0026#39; ctx.fillRect(10, 10, 1, 1) const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height) // 获取 (10, 10) 这个坐标点的像素信息 const pixel = getPixelInfo(imgData, 10, 10) console.log(pixel) 设置某个坐标的像素 基本原理跟获取坐标像素一样，我们可以传入一个 RGBA 值来设置某些坐标的像素。\n// 设置 imageData 中某个坐标的像素 function setPixelInfo(imageData, x, y, rgba) { const { width, data } = imageData const index = (y * width + x) * 4 data[index] = rgba[0] data[index + 1] = rgba[1] data[index + 2] = rgba[2] data[index + 3] = rgba[3] } 测试 // 创建一个10 * 10 imageData 对象 const imgData = ctx.createImageData(10, 10) // RGBA 红色 const rgba = [255, 0, 0, 255] for (let y = 0; y \u0026lt; 10; y++) { for (let x = 0; x \u0026lt; 10; x++) { // 将每个像素点都设置为红色 setPixelInfo(imgData, x, y, rgba) } } // 将 imageData 对象写入到 (100, 100) 开始的位置 ctx.putImageData(imgData, 100, 100) 马赛克小练习 现在我们既能获取到坐标位置的像素，也能设置坐标位置的像素。基于这两点我们来实现一个马赛克的效果。\n基本思路：\n假如现在有一个 100 * 100 的图像，将一个像素点看做一个 1 * 1 的小方块，里面就只有一个 RGBA 值，一共有 100 * 100 = 10000 个小方块，10000 个像素点。\n将这个小方块变大，包含 2 * 2 个像素点，一共有 50 * 50 = 2500 个小方块。\n现在一个小方块里面包含 4 个像素点，可能存在多个 RGBA 值，随机取出其中的一个 RGBA 值，将这个小方块中的 4 个像素点的 RGNA 值，都设置成随机取出的这个 RGBA 值。\n现在每个小方块虽然包含 4 个像素点，但是这 4 个像素点的 RGBA 值都一样，也可以看作现在这个图像只有 2500 个像素点，像素点变少了，图像就模糊了，马赛克效果就形成了。\n/* 设置马赛克像素 imgData：imageData对象 size：马赛克程度，值越大越模糊（小方块宽高） */ function setMosaicPixel(imgData, size) { const { width, height } = imgData // 小方块变大，所以宽高要除以 size for (let y = 0; y \u0026lt; height / size; y++) { for (let x = 0; x \u0026lt; width / size; x++) { // 随机获取小方块中的 (x, y) 坐标 const randomX = x * size + Math.floor(Math.random() * size) const randomY = y * size + Math.floor(Math.random() * size) // 获取这个坐标像素点的 RGBA 值 const randomPixel = getPixelInfo(imgData, randomX, randomY) // 将这个小方块中的像素点都应用这个 RGBA 值 for (let MosaicX = 0; MosaicX \u0026lt; size; MosaicX++) { for (let MosaicY = 0; MosaicY \u0026lt; size; MosaicY++) { setPixelInfo(imgData, x * size + MosaicX, y * size + MosaicY, randomPixel) } } } } } 测试 const img = new Image() img.src = \u0026#39;./img/react.png\u0026#39; img.onload = () =\u0026gt; { // 绘制图像 ctx.drawImage(img, 0, 0, 200, 100) // 获取图像的信息 const imgData = ctx.getImageData(0, 0, 200, 100) // 将图像马赛克化 setMosaicPixel(imgData, 2) // 最后重新写入到画布中 ctx.putImageData(imgData, 0, 0) } canvas透明度 ctx.globalAlpha：这个属性影响到 canvas 里所有图像的透明度，有效的值范围是 0（完全透明）到 1（完全不透明），默认是 1。\n// 画布全局透明度设置为 0.2 ctx.globalAlpha = .2 ctx.fillStyle = \u0026#39;red\u0026#39; ctx.fillRect(50, 50, 50, 50) ctx.fillStyle = \u0026#39;blue\u0026#39; ctx.fillRect(150, 50, 50, 50) canvas图像合成设置 ctx.globalCompositeOperation：设置或返回如何将一个源（新的 source）图像绘制到目标（已有的 destination）的图像上。\n可选值如下:\nsource-over\t源在上面，新的图像层级比较高。（默认值）\nsource-in\t只留下源与目标的重叠部分。（源的那一部分）\nsource-out\t只留下源超过目标的部分。\nsource-atop\t砍掉源溢出的部分。\ndestination-over\t目标在上面，旧的图像层级比较高。\ndestination-in\t只留下源与目标的重叠部分。（目标的那一部分）\ndestination-out\t只留下目标超过源的部分。\ndestination-atop\t砍掉目标溢出的部分。\nlighter\t显示源图像 + 目标图像。（重叠图形的颜色是通过颜色值相加来确定的）\ncopy\t显示源图像，忽略目标图像。\nxor\t那些重叠和正常绘制之外的其他地方是透明的。\n// 设置图像重叠的地方不显示 ctx.globalCompositeOperation = \u0026#39;xor\u0026#39; ctx.fillStyle = \u0026#39;red\u0026#39; ctx.fillRect(50, 50, 50, 50) ctx.fillStyle = \u0026#39;blue\u0026#39; ctx.fillRect(75, 75, 50, 50) 刮刮卡小练习 通过 globalCompositeOperation 属性设置，可以实现一个简单的刮刮卡效果。\n基本思路：\n将 canvas 画布填充一个颜色，和最后要显示的图片宽高设为一致，通过定位将画布覆盖在图片上方\n给 canvas 元素绑定鼠标按下事件，获取当前鼠标按下位置的 offsetX 和 offsetY，相当于在画布中的偏移量，设置起点 moveTo(offsetX, offsetY)。\n给 canvas 元素绑定鼠标移动事件，鼠标按下移动时，实时获取鼠标相对于画布的偏移量，设置 lineTo(offsetX, offsetY)，并将这些路径连接起来。\n设置 ctx.globalCompositeOperation = ‘destination-out’，只留下不是鼠标移动绘制形成的区域，重叠的区域将会透明显示，最下方的图片就能看见。\n给 canvas 元素绑定鼠标松开事件，清除 canvas 身上的鼠标移动事件。\n\u0026lt;!-- 结构设置 --\u0026gt; \u0026lt;div style=\u0026#34;width: 400px;height: 200px;position: relative\u0026#34;\u0026gt; \u0026lt;canvas id=\u0026#34;canvas\u0026#34; width=\u0026#34;400\u0026#34; height=\u0026#34;200\u0026#34; style=\u0026#34;border: 1px solid;position: absolute\u0026#34;\u0026gt;\u0026lt;/canvas\u0026gt; \u0026lt;img id=\u0026#34;img\u0026#34; src=\u0026#34;./img/react.png\u0026#34; style=\u0026#34;width: 100%;height: 100%\u0026#34;\u0026gt; \u0026lt;/div\u0026gt; // 获取 canvas 元素的宽高 const { width, height } = canvas // 将整个画布填充为灰色 ctx.fillStyle = \u0026#39;gray\u0026#39; ctx.fillRect(0, 0, width, height) // 只留下目标超过源的部分 ctx.globalCompositeOperation = \u0026#39;destination-out\u0026#39; // 刮卡的粗细设置为 20px ctx.lineWidth = 20 // 将绘线的路径连接处和两端都设置为圆形，这样比较好看 ctx.lineJoin = \u0026#39;round\u0026#39; ctx.lineCap = \u0026#39;round\u0026#39; // 为 canvas 元素绑定鼠标按下事件 canvas.onmousedown = function(event) { // 获取当前鼠标在画布中的偏移量 const { offsetX, offsetY } = event // 设置起点 ctx.moveTo(offsetX, offsetY) // 为 canvas 元素绑定鼠标移动事件 canvas.onmousemove = function(event) { // 实时获取鼠标的偏移量 const { offsetX, offsetY } = event // 设置路径点 ctx.lineTo(offsetX, offsetY) // 将子路径连接起来绘制显示 ctx.stroke() } // 为 canvas 元素绑定鼠标离开事件 canvas.onmouseup = () =\u0026gt; { // 清除 canvas 元素身上的鼠标移动事件 canvas.onmousemove = null } } canvas将画布导出为图像 canvas.toDataURL(type, encoderOptions)。\n通过 canvas 身上的 toDataURL 方法，返回一个包含画布内容的 base64 格式的 data url。\n参数：\ntype：图片格式，默认为 image/png。 encoderOptions：在指定图片格式为 image/jpeg 或 image/webp 的情况下，可以从 0-1 之间选择图片的质量。如果超出取值范围，将会使用默认值0.92。其他参数会被忽略。 ctx.fillStyle = \u0026#39;red\u0026#39; ctx.fillRect(50, 50, 100, 100) const dataUrl = canvas.toDataURL() // data:image/png;base64,iVBORw0KGgoAAAANSUh.... console.log(dataUrl) 地址栏输入 data url：\ncanvas事件操作 canvas 中几乎没有提供任何事件操作的方法，但是我们可以通过 isPointInPath 方法，判断当前坐标是否在路径列表中，从而进行一些事件操作。\nctx.isPointInPath(x, y)：判断在当前路径中是否包含检测点 (x, y)，返回 true / false。\n特别注意：\nctx.beginPath() 之前的路径检测不到，因为它会清空路径列表。\nfillRect 和 strokeRect 这两个直接绘制矩形的方法不会生成路径，它们包含的坐标点 isPointInPath 检查不到。\n// 绘制一个路径矩形 ctx.rect(50, 50, 100, 100) ctx.fill() // 给 canvas 绑定点击事件 canvas.onclick = event =\u0026gt; { // 鼠标点击位置距离 canvas 的 offsetX 和 offsetY，就相当于在 canvas 中的坐标位置 const { offsetX, offsetY } = event const isInPath = ctx.isPointInPath(offsetX, offsetY) console.log(`当前点击坐标：(${offsetX}, ${offsetY})`, `是否在路径列表中：${isInPath}`) } ","permalink":"https://sirius00.github.io/posts/tech/canvas%E7%9A%84%E4%BD%BF%E7%94%A8/","summary":"canvas画布宽度和高度 canvas标签只有两个标签属性: width和height 当没有设置宽度和高度的时候, canvas会初始化为宽300px, 高150px画布 使用html属性设置width, height 时,只影响画布本身,不影响画布内容 使用css样式指定canvas的width, he","title":"Canvas的使用"},{"content":"Scss的基本用法 声明变量 声明变量的符号 $\n$color: #333; .a { color: $color; } 默认变量 (!default) scss的默认变量仅需要在值后面加上!default即可\n$color: #333 !default; .a { color: $color; } 如果分配给变量的值后面添加了 !default 标志 ，这意味着该变量如果已经赋值，那么它不会被重新赋值，但是，如果它尚未赋值，那么它会被赋予新的给定值\n变量调用 直接调用即可, 变量声明也可以直接调用已声明的变量\n$color: #666; $color2: $color; .b { color: $color2; } 局部变量和全局变量 在元素内部定义的变量不会影响其他元素\nem { $color: red; //定义局部变量 a { color: $color; //调用局部变量 } } 嵌套 选择器嵌套 结构\n\u0026lt;header\u0026gt; \u0026lt;nav\u0026gt; \u0026lt;a href=“##”\u0026gt;Home\u0026lt;/a\u0026gt; \u0026lt;a href=“##”\u0026gt;About\u0026lt;/a\u0026gt; \u0026lt;a href=“##”\u0026gt;Blog\u0026lt;/a\u0026gt; \u0026lt;/nav\u0026gt; \u0026lt;header\u0026gt; scss实现\nnav { a { color: red; header \u0026amp; { color:green; } } } 属性嵌套 Sass 中还提供属性嵌套，CSS 有一些属性前缀相同，只是后缀不一样，比如：border-top/border-right，与这个类似的还有 margin、padding、font 等属性。\n样式如下:\n.box { border-top: 1px solid red; border-bottom: 1px solid green; } sass实现\n.box { border: { top: 1px solid red; bottom: 1px solid green; } } 伪类嵌套 借助 \u0026amp;\nspan { color:red; \u0026amp;:hover { color : green; } } 混合宏 如果你的整个网站中有几处小样式类似，比如颜色，字体等，在 Sass 可以使用变量来统一处理，那么这种选择还是不错的。但当你的样式变得越来越复杂，需要重复使用大段的样式时，使用变量就无法达到我们目了。这个时候 Sass 中的混合宏就会变得非常有意义\n声明 不带参数混合宏 在sass中, 使用\u0026quot;@mixin\u0026quot; 来声明一个混合宏,如:\n@mixin border-radius{ -webkit-border-radius: 5px; border-radius: 5px; } 其中 @mixin 是用来声明混合宏的关键词，有点类似 CSS 中的 @media、@font-face 一样。border-radius 是混合宏的名称。大括号里面是复用的样式代码。\n带参数混合宏 除了声明一个不带参数的混合宏之外，还可以在定义混合宏时带有参数，如：\n@mixin border-radius($radius:5px){ -webkit-border-radius: $radius; border-radius: $radius; } 调用 在 Sass 中通过 @mixin 关键词声明了一个混合宏，那么在实际调用中，其匹配了一个关键词“ @include ”来调用声明好的混合宏。例如在你的样式中定义了一个圆角的混合宏“border-radius”:\n@mixin border-radius{ -webkit-border-radius: 3px; border-radius: 3px; } 在一个按钮中要调用定义好的混合宏“border-radius”，可以这样使用：\nbutton { @include border-radius; } 混合宏的参数 Sass 的混合宏有一个强大的功能，可以传参，那么在 Sass 中传参主要有以下几种情形：\n传一个不带值的参数 在混合宏中，可以传一个不带任何值的参数，比如：\n@mixin border-radius($radius){ -webkit-border-radius: $radius; border-radius: $radius; } 在混合宏“border-radius”中定义了一个不带任何值的参数“$radius”。\n在调用的时候可以给这个混合宏传一个参数值：\n.box { @include border-radius(3px); } 传一个带值的参数 在 Sass 的混合宏中，还可以给混合宏的参数传一个默认值，例如：\n@mixin border-radius($radius:3px){ -webkit-border-radius: $radius; border-radius: $radius; } 在混合宏“border-radius”传了一个参数“$radius”，而且给这个参数赋予了一个默认值“3px”。\n在调用类似这样的混合宏时，会多有一个机会，假设你的页面中的圆角很多地方都是“3px”的圆角，那么这个时候只需要调用默认的混合宏“border-radius”:\n.btn { @include border-radius; } 混合宏的不足 混合宏在实际编码中给我们带来很多方便之处，特别是对于复用重复代码块。但其最大的不足之处是会生成冗余的代码块。比如在不同的地方调用一个相同的混合宏时。如：\n@mixin border-radius{ -webkit-border-radius: 3px; border-radius: 3px; } .box { @include border-radius; margin-bottom: 5px; } .btn { @include border-radius; } 扩展/继承 在 Sass 中是通过关键词 “@extend”来继承已存在的类样式块，从而实现代码的继承。如下所示：\n// SCSS .btn { border: 1px solid #ccc; padding: 6px 10px; font-size: 14px; } .btn-primary { background-color: #f36; color: #fff; @extend .btn; } .btn-second { background-color: orange; color: #fff; @extend .btn; } 占位符 % placeholder 它可以取代以前 CSS 中的基类造成的代码冗余的情形。因为 %placeholder 声明的代码，如果不被 @extend 调用的话，不会产生任何代码。来看一个演示：\n%mt5 { margin-top: 5px; } %pt5{ padding-top: 5px; } 这段代码没有被 @extend 调用，他并没有产生任何代码块，只是静静的躺在你的某个 SCSS 文件中。只有通过 @extend 调用才会产生代码：\n// SCSS %mt5 { margin-top: 5px; } %pt5{ padding-top: 5px; } .btn { @extend %mt5; @extend %pt5; } .block { @extend %mt5; span { @extend %pt5; } } ","permalink":"https://sirius00.github.io/posts/tech/scss%E7%9A%84%E4%BD%BF%E7%94%A8/","summary":"Scss的基本用法 声明变量 声明变量的符号 $ $color: #333; .a { color: $color; } 默认变量 (!default) scss的默认变量仅需要在值后面加上!default即可 $color: #333 !default; .a { color: $color; } 如果分配给变量的值后面添加了 !default 标志 ，这意味着该变量如果已经赋值，那么它不会被重新赋值，但是，如果它尚未赋值，那么它会被赋予新的给定值 变量调用 直","title":"Scss的使用"},{"content":" 教程：https://github.com/jj112358/node-api\n项目的基本优化 nodemon **作用：**自动重新加载当前项目\n安装：npm i nodemon\n**配置：**在package.json修改scripts， 添加如下内容\t：\n\u0026#34;start\u0026#34;: \u0026#34;nodemon ./main.js\u0026#34;, dotenv **作用：**读取配置文件， 设置环境变量\n链接：npm地址\n安装：npm i dotenv\n使用：\n创建.env文件\nPORT = 8080 创建config文件夹， 创建config.default.js文件\nconst dotenv = require(\u0026#39;dotenv\u0026#39;) dotenv.config() module.exports = process.env 在main.js文件中\nconst {PORT} = require(\u0026#39;./config/config.js\u0026#39;) 配置路由 使用 koa-router\n安装：npm i koa-router\n使用：\n创建router文件夹\n创建user.route.js文件\nconst Router = rquire(\u0026#39;koa-router\u0026#39;) const userRouter = new Router({prefix: \u0026#39;/user\u0026#39;}) router.get（\u0026#39;/\u0026#39;， （ctx， next） =\u0026gt; { ctx.body = \u0026#39;hello\u0026#39; }） module.exports = userRouter 改写 main.js 文件\nconst user = require(\u0026#39;./router/user.route\u0026#39;); //引入user app.use(user.routes()); 如何使用路由重定向 如果向直接从 localhost：9000 重定向至 localhost：9000/home 如何实现？\n可以在 router/index.js 中进行如下配置：\nrouter.use（\u0026#39;/home\u0026#39;, home.routes(), home.allowMethods()） ... router.redirect(\u0026#39;/\u0026#39;, \u0026#39;/home\u0026#39;) 目录结构优化 将http服务和app业务拆分 创建app/inde.js文件\nconst Koa = require(\u0026#39;koa\u0026#39;) const userRouter = require(\u0026#39; . ./router /user. route\u0026#39;) const app = new Koa() app.use(userRouter.routes()) module. exports = app 创建controller文件夹， 将路由和控制器分开 例如， 创建user.controller.js文件\nclass UserController { async register (ctx， next) { ctx.body = \u0026#39;用户注册成功\u0026#39; } } 在router/user.route.js文件中引入\nconst {register} = require(\u0026#39;../~\u0026#39;) // 注册接口 router.post(\u0026#39;/register\u0026#39;， register) 解析body， 拆分service 解析body 安装：npm i koa-body\n使用：\nconst { koaBody } = require(\u0026#39;koa-body\u0026#39;); // 解析body app.use(koaBody()); 拆分serveice或model（操作数据库） 创建service或model文件夹\n/* 写法一 exports.createUser = async (username, password) =\u0026gt; { return \u0026#39;写入数据成功\u0026#39; } */ // 写法二 class UserModel { async createUser(username, password) { return \u0026#39;写入数据成功\u0026#39; } } module.exports = new UserModel() 操作数据库 sequelize ORM数据库工具\nsequelize中文文档\nsequelize 自动生成model\n如何使用sequelize automate\n自动生成model使用教程\nORM： 对象关系映射\n数据表映射（对应）一个类 数据表中的数据行（记录）对应一个对象 数据表字段对应对象的属性 数据表操作对应对象的方法 安装： npm i mysql2 sequelize\n使用：\n连接数据库\n错误处理 在app文件夹下， errorHandler.js文件：\nmodule.exports = (err, ctx) =\u0026gt; { let status = 500 switch (err.code) { case \u0026#39;10001\u0026#39;: status = 400 break case \u0026#39;10002\u0026#39;: status = 409 break default: status = 500 } ctx.status = status ctx.body = err console.log(err); } 使用：\nctx.app.emit(\u0026#39;error\u0026#39;, userRegisterError, ctx) 拆分中间件 拆分中间件 创建middleware文件夹\n如user.middleware.js文件：\nconst cryptojs = require(\u0026#39;crypto-js\u0026#39;) const { getUserInfo } = require(\u0026#39;../service/user.service\u0026#39;) const { userFormateError, userAlreadyExited, userRegisterError, userDoesNotExist, userLoginError } = require(\u0026#39;../constant/err.type\u0026#39;) const userValidator = async (ctx, next) =\u0026gt; { const { username, password } = ctx.request.body // 合法性 if (!username || !password) { console.error(\u0026#39;用户名或密码为空\u0026#39;, ctx.request.body) ctx.app.emit(\u0026#39;error\u0026#39;, userFormateError, ctx) return } await next() } const verifyUser = async (ctx, next) =\u0026gt; { const { username } = ctx.request.body try { const res = await getUserInfo({ username }) if (res) { console.error(\u0026#39;用户名已经存在\u0026#39;, { username }) ctx.app.emit(\u0026#39;error\u0026#39;, userAlreadyExited, ctx) return } } catch (err) { console.error(\u0026#39;获取用户信息错误\u0026#39;, err) ctx.app.emit(\u0026#39;error\u0026#39;, userRegisterError, ctx) return } await next() } const cryptoPassword = async (ctx, next) =\u0026gt; { const { password } = ctx.request.body const newPassword = cryptojs.MD5(password).toString() ctx.request.body.password = newPassword // console.log(newPassword); await next() } const verifyLogin = async (ctx, next) =\u0026gt; { // 1. 判断用户是否存在(不存在:报错) const { username, password } = ctx.request.body try { const res = await getUserInfo({ username }) if (!res) { console.error(\u0026#39;用户名不存在\u0026#39;, { username }) ctx.app.emit(\u0026#39;error\u0026#39;, userDoesNotExist, ctx) return } console.log(\u0026#39;res\u0026#39;, res); // 2. 密码是否匹配(不匹配: 报错) const pwd = cryptojs.MD5(password).toString() if (pwd !== res.password) { ctx.app.emit(\u0026#39;error\u0026#39;, invalidPassword, ctx) return } } catch (err) { console.error(err) return ctx.app.emit(\u0026#39;error\u0026#39;, userLoginError, ctx) } await next() } module.exports = { userValidator, verifyUser, cryptoPassword, verifyLogin } 统一错误处理 创建constant文件夹， 新建err.type.js文件， 定义错误常量\nmodule.exports = { userFormateError: { code: \u0026#39;10001\u0026#39;, message: \u0026#39;用户名或密码为空\u0026#39;, result: \u0026#39;\u0026#39;, }, userAlreadyExited: { code: \u0026#39;10002\u0026#39;, message: \u0026#39;用户已经存在\u0026#39;, result: \u0026#39;\u0026#39;, }, userRegisterError: { code: \u0026#39;10003\u0026#39;, message: \u0026#39;用户注册错误\u0026#39;, result: \u0026#39;\u0026#39;, }, userDoesNotExist: { code: \u0026#39;10004\u0026#39;, message: \u0026#39;用户不存在\u0026#39;, result: \u0026#39;\u0026#39;, }, userLoginError: { code: \u0026#39;10005\u0026#39;, message: \u0026#39;用户登录失败\u0026#39;, result: \u0026#39;\u0026#39;, }, invalidPassword: { code: \u0026#39;10006\u0026#39;, message: \u0026#39;密码不匹配\u0026#39;, result: \u0026#39;\u0026#39;, }, tokenExpiredError: { code: \u0026#39;10101\u0026#39;, message: \u0026#39;token已过期\u0026#39;, result: \u0026#39;\u0026#39;, }, invalidToken: { code: \u0026#39;10102\u0026#39;, message: \u0026#39;无效的token\u0026#39;, result: \u0026#39;\u0026#39;, }, } 错误处理函数 调用service层的时候，尽量都加上try catch\n加密 安装bcryptjs（安装crypto-js） 编写加密中间件 在router中使用 用户的认证 登陆成功后， 给用户颁发一个令牌token， 用户在以后的每一次请求中携带这个令牌\njwt： jsonwebtoken\nheader： 头部 payload： 载荷 signature： 签名 颁发token 安装jsonwebtoken\nnpm i jsonwebtoken\n用户认证 创建中间件，auth.middleware.js\nconst jwt = require(\u0026#39;jsonwebtoken\u0026#39;) const { JWT_SECRET } = require(\u0026#39;../config/config\u0026#39;) const { tokenExpiredError, invalidToken } = require(\u0026#39;../constant/err.type\u0026#39;) const auth = async (ctx, next) =\u0026gt; { const { authorization } = ctx.request.header const token = authorization.replace(\u0026#39;Bearer \u0026#39;, \u0026#39;\u0026#39;) console.log(token) try { // user中包含了payload的信息(id, user_name, is_admin) const user = jwt.verify(token, JWT_SECRET) ctx.state.user = user } catch (err) { switch (err.name) { case \u0026#39;TokenExpiredError\u0026#39;: console.error(\u0026#39;token已过期\u0026#39;, err) return ctx.app.emit(\u0026#39;error\u0026#39;, tokenExpiredError, ctx) case \u0026#39;JsonWebTokenError\u0026#39;: console.error(\u0026#39;无效的token\u0026#39;, err) return ctx.app.emit(\u0026#39;error\u0026#39;, invalidToken, ctx) } } await next() } module.exports = { auth, } 在路由中使用：\n// 修改用户信息 router.patch(\u0026#39;/change\u0026#39;, auth, changePassword) 参数校验 使用插件joi\n使用方式：\n创建schema文件夹\n添加参数验证， 如：\nconst joi = require(\u0026#39;joi\u0026#39;) const schema = joi.object({ username: joi.string().required(), password: joi.string().required() }) module.exports = schema 在中间件 文件夹中使用\nconst user_schema = require(\u0026#39;../schema/user.schema\u0026#39;) const addPostValidator = async (ctx, next) =\u0026gt; { // const res = await user_schema.validateAsync(ctx.request.body) try { const value = await user_schema.validateAsync(ctx.request.body); } catch (err) { if(err) { ctx.app.emit(\u0026#39;error\u0026#39;, {code: 1, message: err.details[0].message}, ctx) return } } await next() } module.exports = { addPostValidator } 在router路由中使用\nrouter.post(\u0026#39;/test\u0026#39;, addPostValidator, registerTest) 读取静态文件 安装 koa-static npm i koa-static 引入 const path = rquire（\u0026#39;path\u0026#39;） const static = require(\u0026#39;koa-static\u0026#39;) // 获取静态资源文件夹 app.use(static(path.join(__dirname+ \u0026#39;/assets\u0026#39;))) 上传图片 修改koa-body的使用 app.use(koaBody({ multipart: true, formidable: { uploadDir: \u0026#39;\u0026#39;, keepExtensions: true } })) 新建 upload 文件夹 ","permalink":"https://sirius00.github.io/posts/tech/koa%E6%A1%86%E6%9E%B6/","summary":"教程：https://github.com/jj112358/node-api 项目的基本优化 nodemon **作用：**自动重新加载当前项目 安装：npm i nodemon **配置：**在package.json修改scripts， 添加如下内容 ： \u0026#34;start\u0026#34;: \u0026#34;nodemon ./main.js\u0026#34;, dotenv **作用：**读取配置文件， 设置环境变量 链接：npm地","title":"Koa框架"},{"content":"创建数据库 create database 数据库名\n删除数据库 drop database 数据库名\nmysql数据类型 数值类型 类型 大小 范围（有符号） 范围（无符号） 用途 TINYINT 1 Bytes (-128，127) (0，255) 小整数值 SMALLINT 2 Bytes (-32 768，32 767) (0，65 535) 大整数值 MEDIUMINT 3 Bytes (-8 388 608，8 388 607) (0，16 777 215) 大整数值 INT或INTEGER 4 Bytes (-2 147 483 648，2 147 483 647) (0，4 294 967 295) 大整数值 BIGINT 8 Bytes (-9,223,372,036,854,775,808，9 223 372 036 854 775 807) (0，18 446 744 073 709 551 615) 极大整数值 FLOAT 4 Bytes (-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) 0，(1.175 494 351 E-38，3.402 823 466 E+38) 单精度 浮点数值 DOUBLE 8 Bytes (-1.797 693 134 862 315 7 E+308，-2.225 073 858 507 201 4 E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) 双精度 浮点数值 DECIMAL 对DECIMAL(M,D) ，如果M\u0026gt;D，为M+2否则为D+2 依赖于M和D的值 依赖于M和D的值 小数值 日期/时间类型 类型 大小 ( bytes) 范围 格式 用途 DATE 3 1000-01-01/9999-12-31 YYYY-MM-DD 日期值 TIME 3 \u0026lsquo;-838:59:59\u0026rsquo;/\u0026lsquo;838:59:59\u0026rsquo; HH:MM:SS 时间值或持续时间 YEAR 1 1901/2155 YYYY 年份值 DATETIME 8 \u0026lsquo;1000-01-01 00:00:00\u0026rsquo; 到 \u0026lsquo;9999-12-31 23:59:59\u0026rsquo; YYYY-MM-DD hh:mm:ss 混合日期和时间值 TIMESTAMP 4 \u0026lsquo;1970-01-01 00:00:01\u0026rsquo; UTC 到 \u0026lsquo;2038-01-19 03:14:07\u0026rsquo; UTC结束时间是第 2147483647 秒，北京时间 2038-1-19 11:14:07，格林尼治时间 2038年1月19日 凌晨 03:14:07 YYYY-MM-DD hh:mm:ss 混合日期和时间值，时间戳 字符串类型 类型 大小 用途 CHAR 0-255 bytes 定长字符串 VARCHAR 0-65535 bytes 变长字符串 TINYBLOB 0-255 bytes 不超过 255 个字符的二进制字符串 TINYTEXT 0-255 bytes 短文本字符串 BLOB 0-65 535 bytes 二进制形式的长文本数据 TEXT 0-65 535 bytes 长文本数据 MEDIUMBLOB 0-16 777 215 bytes 二进制形式的中等长度文本数据 MEDIUMTEXT 0-16 777 215 bytes 中等长度文本数据 LONGBLOB 0-4 294 967 295 bytes 二进制形式的极大文本数据 LONGTEXT 0-4 294 967 295 bytes 极大文本数据 mysql的基本使用 select 语句 select username， passward from users； insert into 语句 向数据表中插入新的数据行 insert into users (username, passward) values (\u0026#39;王五\u0026#39;, \u0026#39;555\u0026#39;); update 语句 更新数据表 语法： UPDATE 表名称 SET 列名称=新值 WHERE 列名称=某值 示例1， 更新某一行某一列： update users set passward=\u0026#39;333\u0026#39; where id=1; 示例2， 更新某一行的若干列： update users set passward=\u0026#39;ceshi\u0026#39;, status=1 where id=3; delete 语句 用于 删除表中的行\n语法： DELETE FROM 表名称 WHERE 列名称=值 示例： delete from users where id=3； where 子句 WHERE 子句用于限定选择的标准。在 SELECT、 UPDATE、 DELETE 语句中，皆可使用 WHERE 子句来限定选择的标准。\n查询语句中的 WHERE 条件 SELECT 列名称 FROM 表名称 WHERE 列 运算符 值 更新语句中的 WHERE 条件 UPDATE 表名称 SET 列-新值 WHERE 列 运算符 值 删除语句中的 WHERE 条件 DELETE FROM 表名称 WHERE 列 运算符 值\n实例： select * from users where username\u0026lt;\u0026gt;\u0026#39;张三\u0026#39;; select * from users where username like \u0026#39;%三\u0026#39;; 可以使用的运算符： ![](CleanShot 2023-02-07 at 11.16.55.png)\nAND 和 OR 运算符 语法： AND 和 OR 可在 WHERE 子语句中把两个或多个条件结合起来。\nAND 表示必须同时满足多个条件，相当于 JavaScript 中的 ＆＆ 运算符，例如计 (a !== 10 \u0026amp;\u0026amp; a!== 20)\nOR 表示只要满足任意一个条件即可，相当于 JavaScript 中的 运算符，例如 if(a !== 10 ll a !== 20)\nselect * from users where status=0 and id\u0026gt;2; order by 子句 语法： ORDER BY 语句用于根据指定的列对结果集进行排序。 ORDER BY 语句默认按照升序对记录进行排序。 如果您希望按照降序对记录进行排序，可以使用 DESC 关键字。\n使用示例：\nselect * from users order by status; select * from users order by status DESC; # 降序排列 （ASC升序） 多重排序\n对 users 表中的数据，先按照 status 字段进行降序排序，再按照 username 的字母顺序，进行升序排序，示例如下： select * from users order by status DESC, username ASC; cout（*） 函数和 as 关键字 count（*）函数 COUNT(*) 函数用于返回查询结果的总数据条数，语法格式如下：\nselect count（*） from 表名； select count（*） from users where status=0； as 关键字 如果希望给查询出来的列名称设置别名，可以使用 AS 关键字，示例如下：\nselect count(*) as total from users where status=0； ","permalink":"https://sirius00.github.io/posts/tech/mysql%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","summary":"创建数据库 create database 数据库名 删除数据库 drop database 数据库名 mysql数据类型 数值类型 类型 大小 范围（有符号） 范围（无符号） 用途 TINYINT 1 Bytes (-128，127) (0，255) 小整数值 SMALLINT 2 Bytes (-32 768，32 767) (0，65 535) 大整数值 MEDIUMINT 3 Bytes (-8 388 608，8 388 607) (0，16 777 215) 大整数值 INT或INTEGER 4 Bytes (-2 147 483 6","title":"Mysql的基本使用"},{"content":"","permalink":"https://sirius00.github.io/posts/tech/git%E7%9A%84%E4%BD%BF%E7%94%A8/","summary":"","title":"Git的使用"},{"content":" Sulv\u0026#39;s Blog 一个记录技术、阅读、生活的博客 👉友链格式 名称： Sulv\u0026rsquo;s Blog 网址： https://www.sulvblog.cn 图标： https://www.sulvblog.cn/img/Q.gif 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求 秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内\n👉Hugo博客交流群 787018782\n","permalink":"https://sirius00.github.io/links/","summary":"Sulv\u0026#39;s Blog 一个记录技术、阅读、生活的博客 👉友链格式 名称： Sulv\u0026rsquo;s Blog 网址： https://www.sulvblog.cn 图标： https://www.sulvblog.cn/img/Q.gif 描述： 一个记录技术、阅读、生活的博客 👉友链申请要求 秉承互换友链原则、文章定期更新、不能有太多广告、个人描述字数控制在15字内 👉Hugo博客交流群 787018782","title":"🤝友链"},{"content":"关于我\n英文名: Limene Xu 职业: 程序员 运动: 跑步、乒乓球、爬山 ","permalink":"https://sirius00.github.io/about/","summary":"关于我 英文名: Limene Xu 职业: 程序员 运动: 跑步、乒乓球、爬山","title":"🙋🏻‍♂️关于"},{"content":"","permalink":"https://sirius00.github.io/categories/","summary":"","title":"🏷 分类"}]